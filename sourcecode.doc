目前项目结构：
.
├── CMakeLists.txt
├── idea
├── include
│   ├── Bullet.h
│   ├── Collision.h
│   ├── Entity.h
│   ├── GameStageFwd.h
│   ├── GameStage.h
│   ├── raylib
│   │   ├── raylib.h
│   │   ├── raymath.h
│   │   ├── rcamera.h
│   │   └── rlgl.h
│   ├── ResourceManager.h
│   ├── SpecialEffect.h
│   └── UI.h
├── libs
│   ├── libCollision.a
│   ├── libEntity.a
│   ├── libGameStage.a
│   ├── libraylib.so
│   ├── libResourceManager.a
│   ├── libSpecialEffect.a
│   ├── libStageController.a
│   └── libUI.a
├── outline
├── res
│   ├── enemy.png
│   ├── exit.png
│   ├── fallback.png
│   ├── pen.png
│   ├── player.png
│   ├── restart.png
│   └── warning.png
├── sourcecode.doc
└── src
    ├── CMakeLists.txt
    ├── Collision
    │   ├── CMakeLists.txt
    │   └── Collision.cpp
    ├── Entity
    │   ├── Bullet.cpp
    │   ├── CMakeLists.txt
    │   └── Entity.cpp
    ├── main.cpp
    ├── Managers
    │   ├── CMakeLists.txt
    │   ├── GameStage
    │   │   ├── CMakeLists.txt
    │   │   └── GameStage.cpp
    │   └── ResourceManager
    │       ├── CMakeLists.txt
    │       └── ResourceManager.cpp
    ├── SpecialEffect
    │   ├── CMakeLists.txt
    │   └── SpecialEffect.cpp
    └── UI
        ├── CMakeLists.txt
        └── UI.cpp

13 directories, 47 files
以下是CMakeLists.txt中的内容：
#根目录CMakeLists.txt
cmake_minimum_required(VERSION 3.5.0)
project(SuperKLF)
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(SRC ${PROJECT_SOURCE_DIR}/src)
set(LIBPATH ${PROJECT_SOURCE_DIR}/libs)
set(GAMEPATH ${PROJECT_SOURCE_DIR}/bin)
set(HEADPATH ${PROJECT_SOURCE_DIR}/include)
#可执行文件的输出路径
set(EXECUTABLE_OUTPUT_PATH ${GAMEPATH})
#动态库输出路径
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${LIBPATH})
#静态库输出路径
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${LIBPATH})
file(COPY res DESTINATION ${GAMEPATH}/)
file(COPY config.json DESTINATION ${GAMEPATH}/)
add_compile_definitions(ASSETS_PATH="./res/")
add_subdirectory(${SRC}/Entity)
add_subdirectory(${SRC}/Collision)
add_subdirectory(${SRC}/Managers)
add_subdirectory(${SRC}/SpecialEffect)
add_subdirectory(${SRC}/UI)
add_subdirectory(${PROJECT_SOURCE_DIR}/src)
以下是Bullet.h中的内容：
#ifndef BULLET_H
#define BULLET_H
#include <vector>
extern "C"{
	#include "raylib.h"
}
#include <memory>
#include <string>
#include "GameStageFwd.h"

class Entity;
class BulletEffect;

namespace BULLET{
	//子弹
	const Vector2 BULLET_SIZE={240,240};
	const float BULLET_RADIUS=150.0f;
	//大招
	const float BLAST_DRAWSCALE=0.3f;
	//全局
	const int BASIC_SPEED=160 ;//基础速度，单位是每秒像素	
	const int BASIC_DMG=50;//基础伤害
}

//基础版本子弹，有子弹的基本功能，特效只有伤害
class Bullet{
private:
	Vector2 position;
	Texture2D texture;
	std::string texturePath;
	Vector2 velocity;//速度倍率
	float drawScale=0.1f;//子弹缩放倍率
	int damage;
	float colliderRadius;
	bool active;
	bool shouldRemove=false;
	std::vector<std::shared_ptr<BulletEffect>> effects;

public:
	~Bullet()=default;
	Bullet():shouldRemove(true),active(false){/*默认子弹不会出现在场上*/}
	Bullet(const std::string texPath,const Vector2& vel={0,1},const Vector2& pos={0,0},const int dmg=BULLET::BASIC_DMG,const bool act=false);
	Bullet(const Bullet& proto,const Vector2& begin);

	std::unique_ptr<Bullet> shoot(const Vector2& begin);
	void Draw() const;
	void Update(const float deltaTime,Entity& shooter);
	void checkHit(Entity& shooter);
	void tryTriggerEffects(Entity& shooter,const Occasion& timing) const;
	void addEffect(std::shared_ptr<BulletEffect> effect){effects.push_back(effect);}
	void setDamage(const int dmg){damage=dmg;}
	void setDrawScale(const float val){drawScale=val;}
	void countColliderRadius(const Vector2 size=BULLET::BULLET_SIZE);
	const Vector2 getColliderCentre() const {return {position.x+int(texture.width*drawScale/2),position.y+int(texture.height*drawScale/2)};}
	const float getColliderRadius() const {return colliderRadius;}
	const bool shouldBeRemoved() const{return shouldRemove;}
};
class Blast:public Bullet{

public:
	Blast():Bullet(){}
	Blast(const std::string texPath,const Vector2& vel={0,1},const Vector2& pos={0,0},const int dmg=10*BULLET::BASIC_DMG,const bool act=false)
	:Bullet(texPath,vel,pos,dmg,act){
		setDrawScale(BULLET::BLAST_DRAWSCALE);
		countColliderRadius(BULLET::BULLET_SIZE);
	}
	Blast(const Blast& proto,const Vector2& begin):Bullet(*this,begin){}
};


#endif
以下是Collision.h中的内容：
#ifndef COLLISION_H
#define COLLISION_H

#include "Bullet.h"
#include "Entity.h"
#include "UI.h"

namespace Collision{
	bool checkBulletEntity(const Bullet& aBullet,const Entity& aEntity);
	bool checkEntityEntity(const Entity& a,const Entity& b);
	bool checkIsTouchButton(const Button& aButton);
}

#endif

以下是Entity.h中的内容：
#ifndef ENTITY_H
#define ENTITY_H
extern "C"{
	#include "raylib.h"
}
#include <utility>
#include <vector>
#include <algorithm>
#include <memory>
#include <string>
#include "Bullet.h"

class Entity{
protected:
	Vector2 position;
	Rectangle boxCollider;
	Texture2D texture;
	float attackInterval,attackTimer;//unit:second
	int maxHP,currentHP,energy,maxEnergy,energyRise;
	Entity* opponent;
	Blast blast;
	std::vector<Bullet> bulletPattern;
	std::size_t bulletIndex;
	std::vector<std::unique_ptr<Bullet>> bulletPool;
public:
	explicit Entity(const std::string texPath,const Vector2& pos,const int hp=100
	,const float interval=1,const int MAXenergy=100,const int rise=10
	,const std::vector<Bullet>& pattern={});

	~Entity()=default;
	virtual void Update(const float deltaTime)=0;
	virtual void Draw() const =0;
	virtual void drawHPandEnergy() const=0;
	void fire(Vector2 pos={0,0});
	void fireBlast();
	void takeDamage(const int damage){currentHP=std::max(0,currentHP-damage);}
	bool isAlive() const {return currentHP>0;}
	bool canCastSkill() const{return energy>=maxEnergy;}
	void addEnergy(const int value){
		energy=std::clamp(energy+value,0,maxEnergy);
	}
	void resetEnergy(){energy=0;}
	void reset();
	void addBullet(Bullet aBullet){bulletPattern.push_back(std::move(aBullet));}
	void removeBullet(const int index){bulletPattern.erase(bulletPattern.begin()+index);}
	void setBlast(Blast aBlast){blast=std::move(aBlast);}
	void setOpponent(Entity& opp){opponent=&opp;}
	float& getAttackTimer(){return attackTimer;}
	float& getAttackInterVale(){return attackInterval;}
	int& getEnergyRise(){return energyRise;}
	Entity& getOpponent(){return *opponent;}
	const int getEnergy() const{return energy;}
	const int getHP() const{return currentHP;}
	const int getMaxEnergy() const{return maxEnergy;}
	const Rectangle& getCollider() const{return boxCollider;}

};

class Player:public Entity{
public:
	Player(const std::string texPath,const Vector2& pos,const int hp=100
	,const float interval=1,const int MAXenergy=100,const int rise=10)
	:Entity(texPath,pos,hp,interval,MAXenergy,rise){}
	void Update(const float deltaTime) override;
	void Draw() const override;
	void drawHPandEnergy() const override;
};

class Enemy:public Entity{
public:
	Enemy(const std::string texPath,const Vector2& pos,const int hp=100
	,const float interval=1,const int MAXenergy=100,const int rise=10)
	:Entity(texPath,pos,hp,interval,MAXenergy,rise){}
	void Update(const float deltaTime) override;
	void Draw() const override;
	void drawHPandEnergy() const override;
};
#endif
以下是GameStageFwd.h中的内容：
#ifndef GAMESTAGEFWD_H
#define GAMESTAGEFWD_H
enum class Occasion{OnShoot,OnHit};
enum class GameStage{MainMenu,Battle,Victory,Defeat,Pause,EXIT};
enum class EventSignal{IDLE,EXIT,RESTART};
#endif
以下是GameStage.h中的内容：
#ifndef GAMESTAGE_H
#define GAMESTAGE_H

#include "Entity.h"
#include "GameStageFwd.h"
#include <raylib.h>

class StageController{
private:
	GameStage currentStage;
	EventSignal signal;
	Player* player;
	Enemy* enemy;
	StageController();
	~StageController()=default;
	
public:
	StageController(const StageController&)=delete;
	void operator=(const StageController&)=delete;
	static StageController& Get(){
		static StageController instance;
		return instance;
	}
	void resetGame();
	void bindEntities(Player& p,Enemy& e){player=&p;enemy=&e;}
	const GameStage checkBattleStage() const;
	const GameStage getCurrentStage() const {return currentStage;}
	void transitionTo(const GameStage stage){currentStage=stage;}
	void handleDefeatInput();
};

#endif
以下是ResourceManager.h中的内容：
#ifndef RESOURCEMANAGER_H
#define RESOURCEMANAGER_H
#include <unordered_map>
#include <string>
extern "C"{
	#include "raylib.h"
}

class ResourceManager{
private:
	std::unordered_map<std::string, Texture2D> textures;
	ResourceManager()=default;
	~ResourceManager()=default;
public:
	ResourceManager(const ResourceManager&)=delete;
	void operator=(const ResourceManager&)=delete;
	static ResourceManager& Get(){
		//利用C++11局部静态变量特性
		static ResourceManager instance;
		return instance;
	}
	std::string resizeTexture(const std::string path,const int width,const int height);
	const Texture2D& loadTexture(const std::string path);
	std::unordered_map<std::string, Texture2D>& getTextures(){return textures;}
	void unloadTexture(const std::string path);
	void cleanUp();
};

#endif
以下是SpecialEffect.h中的内容：
#ifndef SPECIALEFFECT_H
#define SPECIALEFFECT_H
#include "Entity.h"
#include "GameStageFwd.h"

class BulletEffectFactory{

};

class BulletEffect{
protected:
	Occasion triggerTime;
public:
	BulletEffect(const Occasion time=Occasion::OnHit):triggerTime(time){}
	virtual void tryTrigger(Entity& shooter,const Occasion& timing)=0;
	const Occasion when() const{return triggerTime;}
};
class GiveDamage:public BulletEffect{
private:
	int damage;
public:
	GiveDamage(int dmg):damage(dmg){triggerTime=Occasion::OnHit;}
	void tryTrigger(Entity& shooter,const Occasion& timing) override;
	void setDamage(const int dmg){damage=dmg;}
};



#endif
以下是UI.h中的内容：
#ifndef UI_H
#define UI_H
#include <string>
extern "C"{
	#include "raylib.h"
}
namespace UI {
	const int BASIC_BUTTON_WIDTH = 200;
	const int BASIC_BUTTON_HEIGHT = 50;
	const float WIDTH_RADIO=0.9f;
	const float HEIGHT_RADIO=0.8f;
	const int MIN_FONT_SIZE=1;
	const int FONTSIZE=40;
	const Font font= GetFontDefault();
}
class Button{
private:
	Rectangle rect;
	std::string text;
	Color color;
	int fontSize;
	Vector2 textPos;
public:
	void Draw() const;
	const Rectangle& getRect() const{return rect;}
	Button()=default;
	Button(Rectangle r,std::string t,Color c);
};
class DefeatUI{
private:
	Button restartButton,exitButton;
	int passLevel=0;
	DefeatUI();
	~DefeatUI()=default;
public:
	DefeatUI(const DefeatUI&)=delete;
	void operator=(const DefeatUI&)=delete;
	static DefeatUI& Get(){
		static DefeatUI instance;
		return instance;
	}
	void reset(){passLevel=0;}
	void advance(const int val){passLevel+=val;}
	const Button& getRestartBtn() const{return restartButton;}
	const Button& getExitBtn() const{return exitButton;}
	void Draw() const;
};

#endif
以下是CMakeLists.txt中的内容：
#./src的CMakeLists.txt
cmake_minimum_required(VERSION 3.5.0)
project(SuperKLF_alpha)
file(GLOB PROJECT_SOURCES CONFIGURE_DEPENDS ${SRC}/*.cpp)
add_executable(${PROJECT_NAME})
target_sources(${PROJECT_NAME} PRIVATE ${PROJECT_SOURCES})
target_include_directories(${PROJECT_NAME} PRIVATE ${HEADPATH})
#依赖库，每次添加库组件都要在这里加上
target_link_libraries(${PROJECT_NAME} PRIVATE raylib)
target_link_libraries(${PROJECT_NAME} PRIVATE Entity)
target_link_libraries(${PROJECT_NAME} PRIVATE Collision)
target_link_libraries(${PROJECT_NAME} PRIVATE ResourceManager)
target_link_libraries(${PROJECT_NAME} PRIVATE GameStage)
target_link_libraries(${PROJECT_NAME} PRIVATE SpecialEffect)
target_link_libraries(${PROJECT_NAME} PRIVATE UI)

target_link_directories(${PROJECT_NAME} PRIVATE ${LIBPATH})
以下是CMakeLists.txt中的内容：
#Collision中的CMakeLists.txt
cmake_minimum_required(VERSION 3.5.0)
#每个依赖库的名字
project(Collision)
file(GLOB CURRENT_FILE ${PROJECT_SOURCE_DIR}/*.cpp)
add_library(${PROJECT_NAME} STATIC ${CURRENT_FILE})
target_include_directories(${PROJECT_NAME} PUBLIC ${HEADPATH})

target_link_directories(${PROJECT_NAME} PRIVATE ${LIBPATH})
以下是Collision.cpp中的内容：
#include "Collision.h"
#include <algorithm>
extern "C"{
	#include <raylib.h>
}
using std::clamp;

bool Collision::checkBulletEntity(const Bullet &aBullet, const Entity &aEntity){
	Vector2 bulletCentre=aBullet.getColliderCentre();
	float bulletRadiu=aBullet.getColliderRadius();

	Rectangle entityBox=aEntity.getCollider();

	//计算矩形边界点与圆心最近的距离
	float closestX=clamp(bulletCentre.x,entityBox.x,entityBox.x+entityBox.width);
	float closestY=clamp(bulletCentre.y,entityBox.y,entityBox.y+entityBox.height);
	float distanceX=bulletCentre.x-closestX;
	float distanceY=bulletCentre.y-closestY;
	float distanceSquare=(distanceX*distanceX)+(distanceY*distanceY);
	return distanceSquare<=(bulletRadiu*bulletRadiu);
}
bool Collision::checkEntityEntity(const Entity &a, const Entity &b){
	return CheckCollisionRecs(a.getCollider(), b.getCollider());
}
bool Collision::checkIsTouchButton(const Button &aButton){
	return CheckCollisionPointRec(GetMousePosition(), aButton.getRect());
}
以下是Bullet.cpp中的内容：
#include <algorithm>
#include <memory>
#include <string>
#include <vector>
extern "C"{
	#include "raylib.h"
}
#include "Bullet.h"
#include "Entity.h"
#include "Collision.h"
#include "ResourceManager.h"
#include "SpecialEffect.h"

const bool isOutOfScreen(const Vector2& pos);

Bullet::Bullet(const std::string texPath,const Vector2& vel,const Vector2& pos,const int dmg,const bool act)
	:position(pos),velocity(vel),active(act),damage(dmg),texturePath(texPath){
		Texture2D origin=ResourceManager::Get().loadTexture(texPath);
		texturePath=ResourceManager::Get().resizeTexture(texPath, BULLET::BULLET_SIZE.x, BULLET::BULLET_SIZE.y);
		texture=ResourceManager::Get().loadTexture(texturePath);
		countColliderRadius();
		effects.push_back(std::shared_ptr<BulletEffect>{});
		effects.back().reset(new GiveDamage(damage));
	}
void Bullet::countColliderRadius(const Vector2 size){
	colliderRadius=drawScale*(std::min(size.x,size.y)/2);
}

Bullet::Bullet(const Bullet& proto,const Vector2& begin)
	:position(begin),velocity(proto.velocity),active(true)
	,colliderRadius(proto.colliderRadius),damage(proto.damage)
	,texture(proto.texture),drawScale(proto.drawScale){
		effects=proto.effects;
	}

std::unique_ptr<Bullet> Bullet::shoot(const Vector2& begin){
	if(active==false){
		//子弹原型时（只有原型会调用这个函数）
		return std::unique_ptr<Bullet>{new Bullet(*this,begin)};
	}else{
		return nullptr;
	}
}
void Bullet::Update(const float deltaTime,Entity& shooter){
	if(active&&!shouldRemove){
		//只有克隆体是“实例”
		position.x+=velocity.x*deltaTime*BULLET::BASIC_SPEED;
		position.y+=velocity.y*deltaTime*BULLET::BASIC_SPEED;
		Draw();
		checkHit(shooter);	
	}
}
void Bullet::checkHit(Entity& shooter) {
	//判断是否碰到目标，如果碰到了，触发效果（包括伤害），并返回true，否则返回false
	if(Collision::checkBulletEntity(*this, shooter.getOpponent())){
		tryTriggerEffects(shooter, Occasion::OnHit);
		shouldRemove=true;
	}else{
		if(isOutOfScreen(this->getColliderCentre())){
			shouldRemove=true;
		}
	}
}
void Bullet::tryTriggerEffects(Entity& shooter,const Occasion& timing) const{
	for(auto effect:effects){
		effect->tryTrigger(shooter,timing);
	}
}
void Bullet::Draw() const { 
	if(IsTextureValid(texture)){
		DrawTextureEx(texture,position,0,drawScale,WHITE); 
		DrawCircleLinesV(getColliderCentre(),colliderRadius,BLUE);
	}
}
const bool isOutOfScreen(const Vector2& pos){
	if(pos.x>GetScreenWidth()||pos.x<0){
		return true;
	}
	if(pos.y>GetScreenWidth()||pos.y<0){
		return true;
	}
	return false;
}
以下是CMakeLists.txt中的内容：
#Entity中的CMakeLists.txt
cmake_minimum_required(VERSION 3.5.0)
#每个依赖库的名字
project(Entity)
file(GLOB CURRENT_FILE ${PROJECT_SOURCE_DIR}/*.cpp)
add_library(${PROJECT_NAME} STATIC ${CURRENT_FILE})
target_include_directories(${PROJECT_NAME} PUBLIC ${HEADPATH})

target_link_directories(${PROJECT_NAME} PRIVATE ${LIBPATH})
以下是Entity.cpp中的内容：
#include "Entity.h"
#include "Bullet.h"
#include "ResourceManager.h"
#include <memory>

extern "C"{
	#include "raylib.h"
}

void updateBulletPool(std::vector<std::unique_ptr<Bullet>>& pool,const float deltaTime,Entity& shooter);
void tryFire(Entity& aEntity,const float deltaTime);
void updateCollision(std::vector<std::unique_ptr<Bullet>>& pool,const float deltaTime,Entity& shooter);

Entity::Entity(const std::string texPath,const Vector2& pos,const int hp,const float interval,const int MAXenergy,const int rise,const std::vector<Bullet>& pattern)
		:position(pos),maxHP(hp),attackInterval(interval),
		 attackTimer(0),energy(0),maxEnergy(MAXenergy),energyRise(rise),
		 bulletIndex(0),bulletPattern(pattern),currentHP(hp),
		 bulletPool{}{
			texture=ResourceManager::Get().loadTexture(texPath);
			if(!IsTextureValid(texture)){
				//当加载不成功时，使用临时图标
				TraceLog(LOG_WARNING, "Using fallback texture for: %s",texPath.c_str());
				texture=ResourceManager::Get().loadTexture(ASSETS_PATH "/fallback.png");
			}
			boxCollider={position.x,position.y,(float)texture.width,(float)texture.height};
		 }
void Entity::reset(){
	currentHP=maxHP;
	energy=0;
	bulletIndex=0;
	bulletPool.clear();
}
void Entity::fire(Vector2 pos){
	if(bulletPattern.empty()){
		return;
	}
	if(pos.x==0&&pos.y==0){
		pos.x=position.x;
		pos.y=position.y;
	}
	bulletPool.push_back(bulletPattern[bulletIndex].shoot(pos));
	bulletIndex=(bulletIndex+1) % bulletPattern.size();
	addEnergy(energyRise);
}
void Entity::fireBlast(){
	bulletPool.push_back(blast.shoot(position));
	resetEnergy();
}

void Player::Update(const float deltaTime){
	tryFire(*this, deltaTime);
	updateBulletPool(bulletPool, deltaTime,*this);
}
void Player::Draw() const {
	DrawTextureV(texture,position,WHITE);
	drawHPandEnergy();
	DrawRectangleLinesEx(boxCollider,5,RED);
}
void Player::drawHPandEnergy() const{
	DrawRectangleLines(0, GetScreenHeight()-40, int(GetScreenWidth()/2), 40, BLACK);
	DrawRectangle(0, GetScreenHeight()-40, int((float(currentHP)/maxHP)*(float(GetScreenWidth())/2)), 40, RED);
	DrawRectangleLines(int(GetScreenWidth()/2), GetScreenHeight()-40, int(GetScreenWidth()/2), 40, BLACK);
	DrawRectangle(int(GetScreenWidth()/2), GetScreenHeight()-40, int((float(energy)/maxEnergy)*(float(GetScreenWidth())/2)), 40, ORANGE);	
}
void Enemy::Update(const float deltaTime){
	tryFire(*this, deltaTime);
	updateBulletPool(bulletPool, deltaTime,*this);
}
void tryFire(Entity& shooter,const float deltaTime){
	float& attackTimer=shooter.getAttackTimer();
	float& attackInterval=shooter.getAttackInterVale();
	attackTimer+=deltaTime;
	if(shooter.getEnergy()==shooter.getMaxEnergy()){
		shooter.fireBlast();
	}	
	if(attackTimer>=attackInterval){
		shooter.fire();
		attackTimer=0;
		shooter.addEnergy(shooter.getEnergyRise());
	}

}

void updateBulletPool(std::vector<std::unique_ptr<Bullet>>& pool,const float deltaTime,Entity& shooter){
	for(auto it=pool.begin();it!=pool.end();){
		(*it)->Update(deltaTime,shooter);
		if((*it)->shouldBeRemoved()){
			it=pool.erase(it);
		}else{
			++it;
		}
	}	
}
void Enemy::Draw() const {
	DrawTextureV(texture,position,WHITE);
	drawHPandEnergy();
	DrawRectangleLinesEx(boxCollider,5,RED);
}
void Enemy::drawHPandEnergy() const{
	DrawRectangleLines(0, 0, int(GetScreenWidth()/2), 40, BLACK);
	DrawRectangle(0, 0, int((float(currentHP)/maxHP)*(float(GetScreenWidth())/2)), 40, RED);
	DrawRectangleLines(int(GetScreenWidth()/2), 0, int(GetScreenWidth()/2), 40, BLACK);
	DrawRectangle(int(GetScreenWidth()/2), 0, int((float(energy)/maxEnergy)*(float(GetScreenWidth())/2)), 40, ORANGE);	
}


以下是main.cpp中的内容：
#ifndef ASSETS_PATH
#define ASSETS_PATH
#include "GameStageFwd.h"
#endif

extern "C" {
	#include "raylib.h"
}
#include <iostream>
#include <memory>
#include "Bullet.h"
#include "Entity.h"
#include "ResourceManager.h"
#include "GameStage.h"

const int WindowWidth=1280;
const int WindowHeight=720;

const Vector2 playerPos={640,500};
const Vector2 enemyPos={640,100};
const Vector2 playerVel={0,-1};
const Vector2 enemyVel={0,1};
using playerPtr=std::unique_ptr<Player>;
using enemyPtr=std::unique_ptr<Enemy>;

void battle(playerPtr& player,enemyPtr& enemy);
void entityInit(std::unique_ptr<Player>&,std::unique_ptr<Enemy>&,StageController& stg);

int main(void){
	InitWindow(WindowWidth,WindowHeight,"SuperKLF");
	StageController& state=StageController::Get();
	ResourceManager& resMgr=ResourceManager::Get();
	std::unique_ptr<Player> player;
	std::unique_ptr<Enemy> enemy;
	entityInit(player, enemy,state);
	SetTargetFPS(180);
	state.transitionTo(GameStage::Battle);
	while(!WindowShouldClose()&&state.getCurrentStage()!=GameStage::EXIT){
		BeginDrawing();
		ClearBackground(WHITE);
		DrawFPS(0, 0);
		GameStage newStage;
		switch(state.getCurrentStage()){
			case(GameStage::MainMenu):
			break;
			case(GameStage::Battle):
			battle(player,enemy);
			newStage=state.checkBattleStage();
			if(newStage!=GameStage::Battle){
				state.transitionTo(newStage);
			}
			break;
			case(GameStage::Victory):
			ClearBackground(WHITE);
			DrawText("You Win!", GetScreenWidth()/2, GetScreenHeight()/2, 120, GOLD);
			break;
			case(GameStage::Defeat):
			state.handleDefeatInput();
			break;
			default:
			std::cout<<"Not Developed!"<<std::endl;
		}
		EndDrawing();
	}
	resMgr.cleanUp();
	CloseWindow();
}

void battle(playerPtr& player,enemyPtr& enemy){
		float deltaTime =GetFrameTime();
		player->Update(deltaTime);
		enemy->Update(deltaTime);
		player->Draw();
		enemy->Draw();
}
void entityInit(std::unique_ptr<Player>& player,std::unique_ptr<Enemy>& enemy,StageController& stg){
	player.reset(new Player(ASSETS_PATH "player.png",playerPos,10,1,100,10));
	enemy.reset(new Enemy {ASSETS_PATH "enemy.png",enemyPos});
	player->setOpponent(*enemy);
	player->addBullet(Bullet(ASSETS_PATH "pen.png",playerVel));
	player->setBlast(Blast(ASSETS_PATH "warning.png",playerVel));
	enemy->setOpponent(*player);
	enemy->addBullet({ASSETS_PATH "pen.png"});
	stg.bindEntities(*player, *enemy);	
}
以下是CMakeLists.txt中的内容：
#这是./src/Managers中的CMakeLists.txt
cmake_minimum_required(VERSION 3.5.0)
project(Managers)
add_subdirectory(${SRC}/Managers/ResourceManager)
add_subdirectory(${SRC}/Managers/GameStage)
以下是CMakeLists.txt中的内容：
#StageController中的CMakeLists.txt
cmake_minimum_required(VERSION 3.5.0)
#每个依赖库的名字
project(GameStage)
file(GLOB CURRENT_FILE ${PROJECT_SOURCE_DIR}/*.cpp)
add_library(${PROJECT_NAME} STATIC ${CURRENT_FILE})
target_include_directories(${PROJECT_NAME} PUBLIC ${HEADPATH})

target_link_directories(${PROJECT_NAME} PRIVATE ${LIBPATH})
以下是GameStage.cpp中的内容：
#include "Entity.h"
extern "C"{
	#include "raylib.h"
}
#include "GameStageFwd.h"
#include "GameStage.h"
#include "UI.h"
#include "Collision.h"

using Collision::checkIsTouchButton;


void responseToSignalFromDefeat(const EventSignal signal);
void drawDefeatScreen(const DefeatUI& ui);

StageController::StageController(){
	currentStage=GameStage::MainMenu;
	signal=EventSignal::IDLE;
	player=nullptr;
	enemy=nullptr;
}

void StageController::resetGame(){
	if(player==nullptr||enemy==nullptr){return;}
	player->reset();
	enemy->reset();
	DefeatUI::Get().reset();
}

const GameStage StageController::checkBattleStage() const{
	if(!player->isAlive()){return GameStage::Defeat;}
	if(!enemy->isAlive()){return GameStage::Victory;}
	return GameStage::Battle;
}
void StageController::handleDefeatInput(){
	DefeatUI& ui=DefeatUI::Get();
	ui.Draw();
	if(IsKeyPressed(KEY_SPACE)){
		responseToSignalFromDefeat(EventSignal::RESTART);
		return;
	}
	if(checkIsTouchButton(ui.getRestartBtn())){
		if(IsMouseButtonPressed(MOUSE_BUTTON_LEFT)){
			responseToSignalFromDefeat(EventSignal::RESTART);
		}
	}
	if(checkIsTouchButton(ui.getExitBtn())){
		if(IsMouseButtonPressed(MOUSE_LEFT_BUTTON)){
			responseToSignalFromDefeat(EventSignal::EXIT);
		}
	}
}
void responseToSignalFromDefeat(const EventSignal signal){
	StageController& ctrl=StageController::Get();
	switch(signal){
		case(EventSignal::RESTART):
		ctrl.resetGame();
		ctrl.transitionTo(GameStage::Battle);
		break;
		case(EventSignal::EXIT):
		ctrl.transitionTo(GameStage::EXIT);
		break;
		case(EventSignal::IDLE):
		break;
	}
}
以下是CMakeLists.txt中的内容：
#ResourceManager中的CMakeLists.txt
cmake_minimum_required(VERSION 3.5.0)
#每个依赖库的名字
project(ResourceManager)
file(GLOB CURRENT_FILE ${PROJECT_SOURCE_DIR}/*.cpp)
add_library(${PROJECT_NAME} STATIC ${CURRENT_FILE})
target_include_directories(${PROJECT_NAME} PUBLIC ${HEADPATH})

target_link_directories(${PROJECT_NAME} PRIVATE ${LIBPATH})
以下是ResourceManager.cpp中的内容：
#include <string>
extern "C"{
	#include "raylib.h"
}

#include "ResourceManager.h"

const Texture2D& ResourceManager::loadTexture(const std::string path){
	if(textures.find(path)!=textures.end()){
		return textures[path];
	}
	if(!FileExists(path.c_str())){
		TraceLog(LOG_ERROR,"[RES] Texture not find: %s",path.c_str());
		return textures[""];
	}
	Texture2D tex=LoadTexture(path.c_str());
	if(!IsTextureValid(tex)){
		TraceLog(LOG_ERROR, "[RES] Failed to load: %s",path.c_str());
		return textures[""];
	}
	textures[path]=tex;
	TraceLog(LOG_INFO, "[RES] Loaded: %s (%d x %d)",path.c_str(),tex.width,tex.height);
	return textures[path];
}


std::string ResourceManager::resizeTexture(const std::string path,const int width,const int height){
	if(textures.find(path)==textures.end()){return "";}
	static int ID=0;
	Image img=LoadImageFromTexture(textures[path]);
	ImageResize(&img,width,height);
	std::string processedPath=path+"_porcessed"+std::to_string(ID);
	textures[processedPath]=LoadTextureFromImage(img);
	UnloadImage(img);
	ID++;
	return processedPath;
}

void ResourceManager::unloadTexture(const std::string path){
	if(textures.find(path)!=textures.end()){
		UnloadTexture(textures[path]);
		textures.erase(path);
		TraceLog(LOG_INFO, "[RES] Unloaded: %s",path.c_str());
	}
}

void ResourceManager::cleanUp(){
	for(auto& [path,tex]:textures){
		UnloadTexture(tex);
	}
	textures.clear();
	TraceLog(LOG_INFO, "[RES] All resources released");
}

以下是CMakeLists.txt中的内容：
#SpecialEffect中的CMakeLists.txt
cmake_minimum_required(VERSION 3.5.0)
#每个依赖库的名字
project(SpecialEffect)
file(GLOB CURRENT_FILE ${PROJECT_SOURCE_DIR}/*.cpp)
add_library(${PROJECT_NAME} STATIC ${CURRENT_FILE})
target_include_directories(${PROJECT_NAME} PUBLIC ${HEADPATH})

target_link_directories(${PROJECT_NAME} PRIVATE ${LIBPATH})
以下是SpecialEffect.cpp中的内容：
#include "SpecialEffect.h"
#include "Entity.h"

void GiveDamage::tryTrigger(Entity& shooter,const Occasion& timing){
	if(timing==Occasion::OnHit){
		shooter.getOpponent().takeDamage(damage);
	}
}
以下是CMakeLists.txt中的内容：
#UI中的CMakeLists.txt
cmake_minimum_required(VERSION 3.5.0)
#每个依赖库的名字
project(UI)
file(GLOB CURRENT_FILE ${PROJECT_SOURCE_DIR}/*.cpp)
add_library(${PROJECT_NAME} STATIC ${CURRENT_FILE})
target_include_directories(${PROJECT_NAME} PUBLIC ${HEADPATH})

target_link_directories(${PROJECT_NAME} PRIVATE ${LIBPATH})
以下是UI.cpp中的内容：
#include "UI.h"
#include "Collision.h"
#include <raylib.h>
bool isButtonPressed(const Button& btn);
bool isButtonHovered(const Button& btn);
Button::Button(Rectangle r,std::string t,Color c){
	rect=r;
	text=t;
	color=c;
	const int maxTextWidth=rect.width*UI::WIDTH_RADIO;
	const int maxFontByHeight=rect.height*UI::HEIGHT_RADIO;
	int low=UI::MIN_FONT_SIZE;
	int high=maxFontByHeight;
	int bestSize=UI::MIN_FONT_SIZE;
	Vector2 textSize;
	int mid;
	while(low<=high){
		mid=(low+high)/2;
		textSize=MeasureTextEx(UI::font, text.c_str(), mid, 1);
		if(textSize.x<=maxTextWidth){
			bestSize=mid;
			low=mid+1;
		}else{
			high=mid-1;
		}
	}
	fontSize=bestSize;
	textSize=MeasureTextEx(UI::font, text.c_str(), fontSize, 1);
	textPos={
		rect.x+(rect.width-textSize.x)/2,
		rect.y+(rect.height-textSize.y)/2
	};
	
}
void Button::Draw() const{
	Color drawColor =color;
	if(isButtonPressed(*this)){
		drawColor=ColorBrightness(color, -0.3f);
	}else if(isButtonHovered(*this)){
		drawColor=ColorBrightness(color, -0.15f);
	}
	DrawRectangleRec(rect, drawColor);
	BeginScissorMode(rect.x, rect.y, rect.width, rect.height);
	DrawTextEx(UI::font, text.c_str(), textPos, fontSize, 1, WHITE);
	EndScissorMode();
}
bool isButtonPressed(const Button& btn){
	return isButtonHovered(btn)&&IsMouseButtonPressed(MOUSE_LEFT_BUTTON);
}
bool isButtonHovered(const Button& btn){
	return Collision::checkIsTouchButton(btn);
}
void DefeatUI::Draw() const{
	ClearBackground(WHITE);	
	DrawRectangle(0, 0, GetScreenWidth(), GetScreenHeight(), Fade(BLACK,0.5f));
	DrawText("Mamba Out!",500,200,2*UI::FONTSIZE,RED);
	DrawText(TextFormat("You have passed %d levels!",passLevel), 500, 350, UI::FONTSIZE, RED);
	restartButton.Draw();
	exitButton.Draw();
}

DefeatUI::DefeatUI(){
	const int screenHeight=GetScreenHeight();
	const int screenWidth=GetScreenWidth();
	restartButton={
	{screenWidth/2.0f-UI::BASIC_BUTTON_WIDTH/2.0f,
		screenHeight*0.6f,
		UI::BASIC_BUTTON_WIDTH,
		UI::BASIC_BUTTON_HEIGHT},
	"[Space]Restart",ORANGE};
	exitButton={{
		screenWidth/2.0f-UI::BASIC_BUTTON_WIDTH/2.0f,
		screenHeight*0.75f,
		UI::BASIC_BUTTON_WIDTH,
		UI::BASIC_BUTTON_HEIGHT},
		"Quit",ORANGE};
}
