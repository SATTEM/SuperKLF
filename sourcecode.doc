目前项目结构：
.
├──  开发任务.txt
├── CMakeLists.txt
├── idea
├── include
│   ├── Bullet.h
│   ├── Collision.h
│   ├── DataManager.h
│   ├── Effect
│   │   ├── BulletEffect.h
│   │   ├── EffectManager.h
│   │   ├── InstantEffectFactory.h
│   │   ├── InstantEffect.h
│   │   ├── RelicEffectFactory.h
│   │   └── RelicEffect.h
│   ├── Entity.h
│   ├── Event
│   │   ├── EventFWD.h
│   │   └── EventSystem.h
│   ├── GameStageFwd.h
│   ├── GameStage.h
│   ├── nlohmann
│   │   ├── json_fwd.hpp
│   │   └── json.hpp
│   ├── raylib
│   │   ├── raylib.h
│   │   ├── raymath.h
│   │   ├── rcamera.h
│   │   └── rlgl.h
│   ├── ResourceManager.h
│   ├── RewardSystem.h
│   ├── UIComponent.h
│   └── UI.h
├── outline
├── res
│   ├── data
│   │   ├── Effects.json
│   │   └── rewards.json
│   └── image
│       ├── attack_speed.png
│       ├── enemy.png
│       ├── exit.png
│       ├── fallback.png
│       ├── health_boost.png
│       ├── pen.png
│       ├── player.png
│       ├── restart.png
│       └── warning.png
├── sourcecode.doc
└── src
    ├── CMakeLists.txt
    ├── Collision
    │   ├── CMakeLists.txt
    │   └── Collision.cpp
    ├── Entity
    │   ├── Bullet.cpp
    │   ├── CMakeLists.txt
    │   └── Entity.cpp
    ├── main.cpp
    ├── Managers
    │   ├── CMakeLists.txt
    │   ├── Data
    │   │   ├── CMakeLists.txt
    │   │   └── DataManager.cpp
    │   ├── GameStage
    │   │   ├── CMakeLists.txt
    │   │   └── GameStage.cpp
    │   └── ResourceManager
    │       ├── CMakeLists.txt
    │       └── ResourceManager.cpp
    ├── RewardSystem
    │   ├── CMakeLists.txt
    │   └── RewardSystem.cpp
    ├── SpecialEffect
    │   ├── BulletEffect.cpp
    │   ├── CMakeLists.txt
    │   ├── EffectManager.cpp
    │   ├── InstantEffect.cpp
    │   └── RelicEffect.cpp
    └── UI
        ├── CMakeLists.txt
        ├── UIComponent
        │   ├── CMakeLists.txt
        │   └── UIComponent.cpp
        └── UI.cpp

20 directories, 65 files
以下是开发任务.txt中的内容：

以下是CMakeLists.txt中的内容：
#根目录CMakeLists.txt
cmake_minimum_required(VERSION 3.5.0)
project(SuperKLF)
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(SRC ${PROJECT_SOURCE_DIR}/src)
set(LIBPATH ${PROJECT_SOURCE_DIR}/libs)
set(GAMEPATH ${PROJECT_SOURCE_DIR}/bin)
set(HEADPATH ${PROJECT_SOURCE_DIR}/include)
#输出clangd要读取的配置
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)
#可执行文件的输出路径
set(EXECUTABLE_OUTPUT_PATH ${GAMEPATH})
#动态库输出路径
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${LIBPATH})
#静态库输出路径
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${LIBPATH})
file(COPY res DESTINATION ${GAMEPATH}/)
file(COPY config.json DESTINATION ${GAMEPATH}/)
add_compile_definitions(ASSETS_IMAGE_PATH="./res/image/")
add_compile_definitions(ASSETS_DATA_PATH="./res/data/")
add_subdirectory(${SRC}/Entity)
add_subdirectory(${SRC}/Collision)
add_subdirectory(${SRC}/UI)
add_subdirectory(${SRC}/SpecialEffect)
add_subdirectory(${SRC}/Managers)
add_subdirectory(${SRC}/RewardSystem)
add_subdirectory(${PROJECT_SOURCE_DIR}/src)

以下是Bullet.h中的内容：
#ifndef BULLET_H
#define BULLET_H

#include <vector>
extern "C"{
	#include "raylib.h"
}
#include <memory>
#include <string>
#include "Effect/BulletEffect.h"

class Entity;


namespace BULLET{
	//子弹
	const Vector2 BULLET_SIZE={240,240};
	const float BULLET_RADIUS=150.0f;
	//大招
	const float BLAST_DRAWSCALE=0.3f;
	//全局
	const int BASIC_SPEED=160 ;//基础速度，单位是每秒像素	
	const int BASIC_DMG=50;//基础伤害
}

//基础版本子弹，有子弹的基本功能，特效只有伤害
class Bullet{
private:
	Vector2 position;
	Texture2D texture;
	std::string texturePath;
	Vector2 velocity;//速度倍率
	float drawScale=0.1f;//子弹缩放倍率
	int damage;
	float colliderRadius;
	bool active;
	bool isOnShoot=true;
	bool shouldRemove=false;
	std::vector<std::shared_ptr<BulletEffect>> effects;

public:
	~Bullet()=default;
	Bullet():shouldRemove(true),active(false){/*默认子弹不会出现在场上*/}
	Bullet(const std::string texPath,const Vector2& vel={0,1},const Vector2& pos={0,0},const int dmg=BULLET::BASIC_DMG,const bool act=false);
	Bullet(const Bullet& proto,const Vector2& begin);

	std::unique_ptr<Bullet> shoot(const Vector2& begin);
	void Update(const float deltaTime,Entity& shooter);
	void addEffect(std::shared_ptr<BulletEffect> effect){effects.push_back(std::move(effect));}
	void setDamage(const int dmg){damage=dmg;}
	void setDrawScale(const float val){drawScale=val;}
	const Vector2 getColliderCentre() const {return {position.x+int(texture.width*drawScale/2),position.y+int(texture.height*drawScale/2)};}
	const float getColliderRadius() const {return colliderRadius;}
	const bool shouldBeRemoved() const{return shouldRemove;}
private:
	void Draw() const;
	void checkHit(Entity& shooter);
	void tryTriggerEffects(Entity& shooter,const Occasion& timing);
protected:
	void countColliderRadius(const Vector2 size=BULLET::BULLET_SIZE);
};
class Blast:public Bullet{

public:
	Blast():Bullet(){}
	Blast(const std::string texPath,const Vector2& vel={0,1},const Vector2& pos={0,0},const int dmg=10*BULLET::BASIC_DMG,const bool act=false)
	:Bullet(texPath,vel,pos,dmg,act){
		setDrawScale(BULLET::BLAST_DRAWSCALE);
		countColliderRadius(BULLET::BULLET_SIZE);
	}
	Blast(const Blast& proto,const Vector2& begin):Bullet(*this,begin){}
};


#endif
以下是Collision.h中的内容：
#ifndef COLLISION_H
#define COLLISION_H

#include "Bullet.h"
#include "Entity.h"
#include "UIComponent.h"

namespace Collision{
	bool checkBulletEntity(const Bullet& aBullet,const Entity& aEntity);
	bool checkEntityEntity(const Entity& a,const Entity& b);
	bool checkIsTouchButton(const Button& aButton);
}

#endif

以下是DataManager.h中的内容：
#ifndef DATAMANAGER_H
#define DATAMANAGER_H
#include "RewardSystem.h"
#include <string>
#include <vector>

namespace DATA {
	const int BASIC_COINS_EARNED=100;
	const float BASIC_COINS_RATE=0.15f;
	const std::string LEVEL_CONFIG_PATH=ASSETS_DATA_PATH "levels.json";
	const std::string REWARD_CONFIG_PATH=ASSETS_DATA_PATH "rewards.json";
	const std::string DATA_PATH=ASSETS_DATA_PATH "data.json";
	const std::string EFFECT_PATH=ASSETS_DATA_PATH "Effects.json";
}

class DataManager{
private:
	int passedLevel=0;
	float rewardRefreshRate=1.f;
	int rewardRefreshBase=10;
	int refreshTimes=0;
	std::vector<Reward> rewards;
	DataManager();
	~DataManager()=default;
public:
	DataManager(const DataManager&)=delete;
	void operator=(const DataManager&)=delete;
	static DataManager& Get(){
		static DataManager instance;
		return instance;
	}	
	void levelAdvance(){passedLevel+=1;}
	void refreshTimesAdvance(){refreshTimes+=1;}
	void setRewardRefreshBase(const int base){rewardRefreshBase=base;}
	void setRewardRefreshRate(const float rate){rewardRefreshRate=rate;}
	void resetRefreshTimes(){refreshTimes=0;}
	void reset(){passedLevel=0;rewardRefreshRate=1.f;rewardRefreshBase=10;refreshTimes=0;}
	const int getRefreshMoney() const{return refreshTimes*rewardRefreshBase*rewardRefreshRate;}
	const int getRefreshTimes() const{return refreshTimes;}
	const int getPassedLevel() const{return passedLevel;}
	const int getCoinsEarned() const;
	const Reward& getReward(const int i);
	const int getRewardSize() const {return rewards.size();}
};
#endif
以下是BulletEffect.h中的内容：
#ifndef BULLETEFFECT_H
#define BULLETEFFECT_H
#include "../Event/EventFWD.h"
class Entity;
class BulletEffect{
protected:
	Occasion triggerTime;
public:
	BulletEffect(const Occasion time=Occasion::OnHit):triggerTime(time){}
	virtual void tryTrigger(Entity& shooter,const Occasion& timing)=0;
};
class GiveDamage:public BulletEffect{
private:
	int damage;
public:
	GiveDamage(const int dmg):damage(dmg){triggerTime=Occasion::OnHit;}
	void tryTrigger(Entity& shooter,const Occasion& timing)override;
};
#endif
以下是EffectManager.h中的内容：
#ifndef EFFECTMANAGER_H
#define EFFECTMANAGER_H
#include "InstantEffect.h"
#include "RelicEffect.h"
#include "nlohmann/json.hpp"
#include "InstantEffectFactory.h"
#include "RelicEffectFactory.h"
#include <memory>
#include <string>
#include <map>
#include <unordered_map>

class EffectManager{
private:
	EffectManager()=default;
	~EffectManager()=default;
	std::map<int,std::string> instantIDs;
	std::map<int,std::string> relicIDs;
public:
	EffectManager(const EffectManager&)=delete;
	void operator=(const EffectManager&)=delete;
	static EffectManager& Get(){
		static EffectManager instance;
		return instance;
	}
	//分发加载任务并获得所有效果id的集合
	void loadEffects(const nlohmann::json&);
	//从InstantEffectLoader获取一个即时效果
	std::shared_ptr<InstantEffect> getInstantEffect(const std::string&)const;
	std::shared_ptr<InstantEffect> getInstantEffect(const int index)const;
	//Relic效果同理
	std::shared_ptr<RelicEffect> getRelicEffect(const std::string&) const;
	std::shared_ptr<RelicEffect> getRelicEffect(const int index)const;
	//检查是否已经加载了效果
	bool isInstantEffectLoaded(const std::string& id) const;
	bool isRelicEffectLoaded(const std::string& id) const;
	const std::map<int,std::string>& getInstantEffectMap()const{return instantIDs;}
	const std::map<int,std::string>& getRelicEffectMap()const{return relicIDs;}
};
class InstantEffectLoader{
private:
	InstantEffectLoader()=default;
	~InstantEffectLoader()=default;
	std::unordered_map<std::string, std::unique_ptr<InstantEffectFactory>> factories;
public:
	InstantEffectLoader(const InstantEffectLoader&)=delete;
	void operator=(const InstantEffectLoader&)=delete;
	static InstantEffectLoader& Get(){
		static InstantEffectLoader instance;
		return instance;
	}
	//加载json中即时效果数组的每一个元素的工厂
	std::map<int,std::string> loadInstantEffect(const nlohmann::json& effects);
	//通过已加载的效果工厂创建效果
	std::shared_ptr<InstantEffect> getEffect(const std::string&);
	//检查是否存在某效果
	bool isEffectLoaded(const std::string& id) const;
};
//RelicEffect
class RelicEffectLoader{
private:
	RelicEffectLoader()=default;
	~RelicEffectLoader()=default;
	std::unordered_map<std::string, std::shared_ptr<RelicEffectFactory>> factories;
public:
	RelicEffectLoader(const RelicEffectLoader&)=delete;
	void operator=(const RelicEffectLoader&)=delete;
	static RelicEffectLoader& Get(){
		static RelicEffectLoader instance;
		return instance;
	}
	//加载json中遗物效果数组的每一个元素
	std::map<int,std::string> loadRelicEffect(const nlohmann::json& json);
	//通过已加载的效果工厂创建效果
	std::shared_ptr<RelicEffect> getEffect(const std::string&);
	//检查是否存在某效果
	bool isEffectLoaded(const std::string& id)const;
};
#endif
以下是InstantEffectFactory.h中的内容：
#ifndef INSTANTEFFECTFACTORY_H
#define INSTANTEFFECTFACTORY_H
#include "InstantEffect.h"
#include "nlohmann/json.hpp"
#include <memory>
extern "C"{
	#include "raylib.h"
}
class InstantEffectFactory{
public:
	//创建一个即时效果，需要的固定参数都由加载时内置
	//可变参数由set()相关方法设置（需要时特化）
	virtual std::shared_ptr<InstantEffect> create()=0;
	virtual void loadFromJson(const nlohmann::json&)=0;
	InstantEffectFactory()=default;
	virtual ~InstantEffectFactory()=default;
};

template<typename T>
class ConcreteInstantEffectFactory:public InstantEffectFactory{
private:
	nlohmann::json params;
public:
	std::shared_ptr<InstantEffect> create() override{
		TraceLog(LOG_INFO,"Creating instant effect: %s",typeid(T).name());
		return std::make_shared<T>(params);
	}
	void loadFromJson(const nlohmann::json& p) override{
		params=p;
	}
};


#endif
以下是InstantEffect.h中的内容：
#ifndef INSTANTEFFECT_H
#define INSTANTEFFECT_H
#include <raylib.h>
#include <variant>
#include "nlohmann/json.hpp"
#include "Entity.h"
class InstantEffect{
public:
	InstantEffect()=default;
	virtual void onApply(Player& player)const =0;
	virtual ~InstantEffect()=default;
};
class NullInstantEffect:public InstantEffect{
public:
	NullInstantEffect(const nlohmann::json& params):InstantEffect(){}
	void onApply(Player& player) const override final{
		TraceLog(LOG_WARNING, "Applying a NullInstantEffect");
	}
	virtual ~NullInstantEffect(){}
};

class SpeedBoost:public InstantEffect{
private:
	float rate;
public:
	SpeedBoost(const nlohmann::json& params);
	void onApply(Player& player) const override final;
	virtual ~SpeedBoost() override=default;
};

class HealthBoost:public InstantEffect{
private:
	std::variant<int,float> value;
public:
	HealthBoost(const nlohmann::json& params);
	void onApply(Player& player) const override final;
	virtual ~HealthBoost()=default;
};

class NewRelic:public InstantEffect{
private:
	std::string relic_id;
public:
	NewRelic(const nlohmann::json& params);
	void onApply(Player& player) const override final;
	void setRelicID(const std::string& id);
	virtual ~NewRelic()=default;
};

#endif
以下是RelicEffectFactory.h中的内容：
#ifndef RELICEFFECTFACTORY_H
#define RELICEFFECTFACTORY_H
#include "RelicEffect.h"
#include "nlohmann/json.hpp"
#include <memory>
class RelicEffectFactory{
public:
	virtual std::shared_ptr<RelicEffect> create()=0;
	virtual void loadFromJson(const nlohmann::json&)=0;
};
template<typename T>
class ConcreteRelicFactory:public RelicEffectFactory{
private:
	nlohmann::json params;
public:
	std::shared_ptr<RelicEffect> create() override{
		TraceLog(LOG_INFO,"Creating relic effect: %s",typeid(T).name());
		return std::make_unique<T>(params);
	}
	void loadFromJson(const nlohmann::json& relic) override{
		params=relic;
	}
};
#endif
以下是RelicEffect.h中的内容：
#ifndef RELICEFFECT_H
#define RELICEFFECT_H
#include <string>
extern "C"{
	#include "raylib.h"
}
#include "nlohmann/json.hpp"
#include "Event/EventFWD.h"
class Entity;
class RelicEffect{
protected:
	bool isActive=false;
	std::string description;
public:
	RelicEffect()=default;
	virtual ~RelicEffect()=default;
	virtual void onTrigger(Entity& relatedEntity)=0;
	const std::string getDescription() const{return description;}
	virtual Occasion getOccasion() const=0;
};

class NullRelicEffect:public RelicEffect{
public:
	NullRelicEffect(const nlohmann::json& params):RelicEffect(){
		description="No effect";
	}
	void onTrigger(Entity& relatedEntity) override final{
		TraceLog(LOG_WARNING, "Applying a NullRelicEffect");
	}
	Occasion getOccasion() const override final{return Occasion::Undecided;}
	virtual ~NullRelicEffect()=default;
};

class DoubleShootRelic:public RelicEffect{
public:
	DoubleShootRelic(const nlohmann::json& params);
	void onTrigger(Entity& relatedEntity) override final;
	Occasion getOccasion() const override final{return Occasion::OnShoot;}
};


#endif
以下是Entity.h中的内容：
#ifndef ENTITY_H
#define ENTITY_H
extern "C"{
	#include "raylib.h"
}
#include <utility>
#include <vector>
#include <algorithm>
#include <memory>
#include <string>
#include "Bullet.h"
#include "Effect/RelicEffect.h"
namespace GameInit{
	const int Start_Money=33;
}
class Entity{
protected:
	Vector2 position;
	Rectangle boxCollider;
	Texture2D texture;
	float attackInterval,attackTimer;//unit:second
	int maxHP,currentHP,energy,maxEnergy,energyRise;
	Entity* opponent;
	Blast blast;
	std::vector<Bullet> bulletPattern;
	std::size_t bulletIndex;
	std::vector<std::unique_ptr<Bullet>> bulletPool;
	std::vector<std::shared_ptr<RelicEffect>> relics;
public:
	explicit Entity(const std::string texPath,const Vector2& pos,const int hp=100
	,const float interval=1,const int MAXenergy=100,const int rise=10
	,const std::vector<Bullet>& pattern={});

	~Entity()=default;
	virtual void Update(const float deltaTime)=0;
	void fire(Vector2 pos={0,0});
	void fireBlast();
	void takeDamage(const int damage);
	bool isAlive() const {return currentHP>0;}
	bool canCastSkill() const{return energy>=maxEnergy;}
	void reset();
	void addBullet(Bullet aBullet){bulletPattern.push_back(std::move(aBullet));}
	void removeBullet(const int index){bulletPattern.erase(bulletPattern.begin()+index);}
	void setBlast(Blast aBlast){blast=std::move(aBlast);}
	void setOpponent(Entity& opp){opponent=&opp;}
	void addRelic(std::shared_ptr<RelicEffect> relic);
	float& getAttackTimer(){return attackTimer;}
	float& getAttackInterVale(){return attackInterval;}
	Entity& getOpponent(){return *opponent;}
	const int getEnergy() const{return energy;}
	const int getHP() const{return currentHP;}
	const int getMaxEnergy() const{return maxEnergy;}
	const Rectangle& getCollider() const{return boxCollider;}
private:
	void addEnergy(const int value){energy=std::clamp(energy+value,0,maxEnergy);}
	virtual void Draw() const =0;
	virtual void drawHPandEnergy() const=0;
	void resetEnergy(){energy=0;}
};

class Player:public Entity{
private:
	int money=GameInit::Start_Money;
public:
	Player(const std::string texPath,const Vector2& pos,const int hp=100
	,const float interval=1,const int MAXenergy=100,const int rise=10)
	:Entity(texPath,pos,hp,interval,MAXenergy,rise){}
	void Update(const float deltaTime) override;
	void setAttackInterval(const float rate){attackInterval*=rate;}
	void MaxHealthBoost(const int val){maxHP+=val;}
	void MaxHealthBoost(const float rate){maxHP*=rate;}
	void addMoney(const int value){money+=value;}
	const bool deductMoney(const int value){
		if(money-value<0){return false;}
		else{money-=value;return true;}
	}
	const int getMoney() const{return money;}
private:
	void Draw() const override;
	void drawHPandEnergy() const override;
};

class Enemy:public Entity{
public:
	Enemy(const std::string texPath,const Vector2& pos,const int hp=100
	,const float interval=1,const int MAXenergy=100,const int rise=10)
	:Entity(texPath,pos,hp,interval,MAXenergy,rise){}
	void Update(const float deltaTime) override;
private:
	void Draw() const override;
	void drawHPandEnergy() const override;
};
#endif
以下是EventFWD.h中的内容：
#ifndef EVENTFWD_H
#define EVENTFWD_H
enum class Occasion{
	OnShoot,
	OnBlastShoot,
	OnHit,
	Instant,
	OnBattleStart,
	OnHPThreshold,
	Undecided
};
#endif
以下是EventSystem.h中的内容：
#ifndef EVENTSYSTEM_H
#define EVENTSYSTEM_H
#include "Effect/RelicEffect.h"
#include <memory>
#include <unordered_map>
#include <list>
#include <algorithm>
#include "EventFWD.h"
class Entity;

class EventSystem{
private:
	EventSystem()=default;
	~EventSystem()=default;
	std::unordered_map<Occasion,std::list<std::shared_ptr<RelicEffect>>> listeners;
public:
	static EventSystem& Get(){
		static EventSystem instance;
		return instance;
	}
	//将遗物，事件绑定在一起
	void bindRelicAndEvent(std::shared_ptr<RelicEffect>& relic){
		Occasion event=relic->getOccasion();
		listeners[event].push_back(relic);
	}
	//广播某事件，同时传入相关的实体
	void broadcastEvent(Occasion event,Entity& relatedEntity){
		if(listeners.find(event)==listeners.end()){
			listeners[event]={};
		}
		for(auto& relic:listeners[event]){
			relic->onTrigger(relatedEntity);
		}
	}
	//解除绑定
	void unbindRelicAndEvent(std::shared_ptr<RelicEffect> relic,Occasion event){
		auto it=std::find_if(listeners[event].begin(),listeners[event].end(),
		[&relic](std::shared_ptr<RelicEffect>& iterator)->bool{return iterator==relic;});
		listeners[event].erase(it);
	}

};
#endif
以下是GameStageFwd.h中的内容：
#ifndef GAMESTAGEFWD_H
#define GAMESTAGEFWD_H

enum class GameStage{MainMenu,Battle,Victory,Defeat,Pause,Exit,NextLevel};
enum class EventSignal{IDLE,EXIT,RESTART};
#endif
以下是GameStage.h中的内容：
#ifndef GAMESTAGE_H
#define GAMESTAGE_H
#include "Entity.h"
#include "GameStageFwd.h"
#include <raylib.h>
#include <memory>


class StageController{
private:
	GameStage currentStage;
	EventSignal signal;
	std::unique_ptr<Player> player;
	std::unique_ptr<Enemy> enemy;
	StageController();
	~StageController()=default;
	void beginBattle();
	void battleUpdate();
	void mainMenuUpdate();
	void pauseUpdate();
	void victoryUpdate();
	void defeatUpdate();	
	void nextLevel();
public:
	StageController(const StageController&)=delete;
	void operator=(const StageController&)=delete;
	static StageController& Get(){
		static StageController instance;
		return instance;
	}
	void resetGame();
	void bindEntities(std::unique_ptr<Player>&& p,std::unique_ptr<Enemy>&& e){player.reset(p.release());enemy.reset(e.release());}
	Player& getPlayer(){return *player;}
	Enemy& getEnemy(){return *enemy;}
	void update();
	const GameStage getCurrentStage() const {return currentStage;}
	void transitionTo(const GameStage stage){currentStage=stage;}
};

#endif
以下是ResourceManager.h中的内容：
#ifndef RESOURCEMANAGER_H
#define RESOURCEMANAGER_H
#include <unordered_map>
#include <string>
extern "C"{
	#include "raylib.h"
}
namespace UI {
	const std::string FONT_PATH="";
}
class ResourceManager{
private:
	std::unordered_map<std::string, Texture2D> textures;
	Font font;
	bool isFontAssigned=false;
	ResourceManager()=default;
	~ResourceManager()=default;
public:
	ResourceManager(const ResourceManager&)=delete;
	void operator=(const ResourceManager&)=delete;
	static ResourceManager& Get(){
		//利用C++11局部静态变量特性
		static ResourceManager instance;
		return instance;
	}
	std::string resizeTexture(const std::string path,const int width,const int height);
	const Texture2D& loadTexture(const std::string path);
	std::unordered_map<std::string, Texture2D>& getTextures(){return textures;}
	const Font& loadFont();
	void unloadTexture(const std::string path);
	void cleanUp();
};

#endif
以下是RewardSystem.h中的内容：
#ifndef REWARDSYSTEM_H
#define REWARDSYSTEM_H

#include <memory>
#include <string>
#include "Effect/InstantEffect.h"
#include "Entity.h"
extern "C"{
	#include "raylib.h"
}
class Entity;
class Reward{
protected:
	std::string name;
	std::string description;
	std::shared_ptr<InstantEffect> effect;
	Texture2D icon;
public:
	Reward(const nlohmann::json& reward);
	~Reward()=default;
	void apply(Player& player);
	const std::string& getDescription()const{return description;}
	const std::string& getName()const{return name;}
};
#endif
以下是UIComponent.h中的内容：
#ifndef UICOMPONENT_H
#define UICOMPONENT_H
#include <string>
extern "C"{
	#include "raylib.h"
}
namespace UI{
	const int BASIC_BUTTON_WIDTH = 200;
	const int BASIC_BUTTON_HEIGHT = 50;
	const float WIDTH_RADIO=0.9f;
	const float HEIGHT_RADIO=0.5f;
	const int MIN_FONT_SIZE=1;	
	const int FONTSIZE=40;
	const int EXPLAIN_FONTSIZE=15;
	const float countTextPosX(const std::string& str,const int origin,const int fontSize,const int offset=0);
	
}

class Button{
protected:
	bool available=true;
	Rectangle rect;
	std::string text;
	Color color;
	int fontSize;
	Vector2 textPos;
	void resetPosAndSize();
public:
	virtual void Draw() const;
	const Rectangle& getRect() const{return rect;}
	void setAvailibility(const bool a){available=a;}
	void setText(const std::string& str){text=str;resetPosAndSize();}
	std::string getText()const{return text;}
	Button()=default;
	Button(Rectangle r,std::string t,Color c);
};
class ButtonWithNumber:public Button{
private:
	std::string addition;
public:
	ButtonWithNumber()=default;
	ButtonWithNumber(Rectangle r,std::string t,Color c,std::string a="")
	:Button(r,t,c),addition(a){}
	void setAddition(const std::string& str){addition=str;}
	void Draw() const override;
};
class ButtonWithExplain:public Button{
private:
	std::string explain;
	void DrawExplain() const;
public:
	ButtonWithExplain()=default;
	ButtonWithExplain(Rectangle r,std::string t,Color c,std::string e):Button(r,t,c),explain(e){}
	void setExplain(const std::string& str){explain=str;}
	void Draw() const override;
};

#endif
以下是UI.h中的内容：
#ifndef UI_H
#define UI_H
#include "Entity.h"
#include "RewardSystem.h"
#include <vector>
#include "UIComponent.h"
namespace UI {
	const int MAX_ENGLISH_EXPLAIN_LINE=24;
}
class DefeatUI{
private:
	Button restartButton,exitButton;
	DefeatUI();
	~DefeatUI()=default;
public:
	DefeatUI(const DefeatUI&)=delete;
	void operator=(const DefeatUI&)=delete;
	static DefeatUI& Get(){
		static DefeatUI instance;
		return instance;
	}
	const Button& getRestartBtn() const{return restartButton;}
	const Button& getExitBtn() const{return exitButton;}
	void Draw() const;
};
class VictoryUI{
private:
	VictoryUI();
	~VictoryUI()=default;
	ButtonWithExplain rewardBtn[3];
	ButtonWithNumber refreshBtn;
	std::vector<Reward> currentRewards;
public:
	VictoryUI(const VictoryUI&)=delete;
	void operator=(const VictoryUI&)=delete;
	static VictoryUI& Get(){
		static VictoryUI instance;
		return instance;
	}
	void Draw() const;
	void tryGenerateRewards(Player& player);
	void chooseReward(const int i,Player& player);
	const Button& getRewardBtn(int i) const{return rewardBtn[i];}
	const ButtonWithNumber& getRefreshBtn() const{return refreshBtn;}
};

#endif
以下是CMakeLists.txt中的内容：
#./src的CMakeLists.txt
cmake_minimum_required(VERSION 3.5.0)
project(SuperKLF_alpha)
file(GLOB PROJECT_SOURCES CONFIGURE_DEPENDS ${SRC}/*.cpp)
add_executable(${PROJECT_NAME})
target_sources(${PROJECT_NAME} PRIVATE ${PROJECT_SOURCES})
target_include_directories(${PROJECT_NAME} PRIVATE ${HEADPATH})
#依赖库，每次添加库组件都要在这里加上
target_link_libraries(${PROJECT_NAME} PRIVATE 
	raylib
	Entity
	Collision
	ResourceManager
	GameStage
	SpecialEffect
	UIComponent
	UI
	Data
	RewardSystem)
target_link_directories(${PROJECT_NAME} PRIVATE ${LIBPATH})
以下是CMakeLists.txt中的内容：
#Collision中的CMakeLists.txt
cmake_minimum_required(VERSION 3.5.0)
#每个依赖库的名字
project(Collision)
file(GLOB CURRENT_FILE ${PROJECT_SOURCE_DIR}/*.cpp)
add_library(${PROJECT_NAME} STATIC ${CURRENT_FILE})
target_include_directories(${PROJECT_NAME} PUBLIC ${HEADPATH})

target_link_directories(${PROJECT_NAME} PRIVATE ${LIBPATH})
以下是Collision.cpp中的内容：
#include "Collision.h"
#include <algorithm>
extern "C"{
	#include <raylib.h>
}
using std::clamp;

bool Collision::checkBulletEntity(const Bullet &aBullet, const Entity &aEntity){
	Vector2 bulletCentre=aBullet.getColliderCentre();
	float bulletRadiu=aBullet.getColliderRadius();

	Rectangle entityBox=aEntity.getCollider();

	//计算矩形边界点与圆心最近的距离
	float closestX=clamp(bulletCentre.x,entityBox.x,entityBox.x+entityBox.width);
	float closestY=clamp(bulletCentre.y,entityBox.y,entityBox.y+entityBox.height);
	float distanceX=bulletCentre.x-closestX;
	float distanceY=bulletCentre.y-closestY;
	float distanceSquare=(distanceX*distanceX)+(distanceY*distanceY);
	return distanceSquare<=(bulletRadiu*bulletRadiu);
}
bool Collision::checkEntityEntity(const Entity &a, const Entity &b){
	return CheckCollisionRecs(a.getCollider(), b.getCollider());
}
bool Collision::checkIsTouchButton(const Button &aButton){
	return CheckCollisionPointRec(GetMousePosition(), aButton.getRect());
}
以下是Bullet.cpp中的内容：
#include "Event/EventFWD.h"
#include <algorithm>
#include <memory>
#include <string>
#include <vector>
extern "C"{
	#include "raylib.h"
}
#include "Bullet.h"
#include "Entity.h"
#include "Collision.h"
#include "ResourceManager.h"
#include "Event/EventSystem.h"

const bool isOutOfScreen(const Vector2& pos);

Bullet::Bullet(const std::string texPath,const Vector2& vel,const Vector2& pos,const int dmg,const bool act)
	:position(pos),velocity(vel),active(act),damage(dmg),texturePath(texPath){
		Texture2D origin=ResourceManager::Get().loadTexture(texPath);
		texturePath=ResourceManager::Get().resizeTexture(texPath, BULLET::BULLET_SIZE.x, BULLET::BULLET_SIZE.y);
		texture=ResourceManager::Get().loadTexture(texturePath);
		countColliderRadius();
		effects.push_back(std::make_shared<GiveDamage>(GiveDamage(damage)));
	}
void Bullet::countColliderRadius(const Vector2 size){
	colliderRadius=drawScale*(std::min(size.x,size.y)/2);
}

Bullet::Bullet(const Bullet& proto,const Vector2& begin)
	:position(begin),velocity(proto.velocity),active(true)
	,colliderRadius(proto.colliderRadius),damage(proto.damage)
	,texture(proto.texture),drawScale(proto.drawScale){
		effects=proto.effects;
	}

std::unique_ptr<Bullet> Bullet::shoot(const Vector2& begin){
	if(active==false){
		//子弹原型时（只有原型会调用这个函数）
		return std::make_unique<Bullet>(*this,begin);
	}else{
		return nullptr;
	}
}
void Bullet::Update(const float deltaTime,Entity& shooter){
	if(active&&!shouldRemove){
		if(isOnShoot){
			tryTriggerEffects(shooter, Occasion::OnShoot);
			EventSystem::Get().broadcastEvent(Occasion::OnHit, shooter);
			isOnShoot=false;
		}
		position.x+=velocity.x*deltaTime*BULLET::BASIC_SPEED;
		position.y+=velocity.y*deltaTime*BULLET::BASIC_SPEED;
		Draw();
		checkHit(shooter);	
	}
}
void Bullet::checkHit(Entity& shooter) {
	if(Collision::checkBulletEntity(*this, shooter.getOpponent())){
		tryTriggerEffects(shooter, Occasion::OnHit);
		shouldRemove=true;
	}else{
		if(isOutOfScreen(this->getColliderCentre())){
			shouldRemove=true;
		}
	}
}
void Bullet::tryTriggerEffects(Entity& shooter,const Occasion& timing){
	for(auto& effect :effects){
		effect->tryTrigger(shooter, timing);
	}
}
void Bullet::Draw() const { 
	if(IsTextureValid(texture)){
		DrawTextureEx(texture,position,0,drawScale,WHITE); 
		DrawCircleLinesV(getColliderCentre(),colliderRadius,BLUE);
	}
}
const bool isOutOfScreen(const Vector2& pos){
	if(pos.x>GetScreenWidth()||pos.x<0){
		return true;
	}
	if(pos.y>GetScreenWidth()||pos.y<0){
		return true;
	}
	return false;
}
以下是CMakeLists.txt中的内容：
#Entity中的CMakeLists.txt
cmake_minimum_required(VERSION 3.5.0)
#每个依赖库的名字
project(Entity)
file(GLOB CURRENT_FILE ${PROJECT_SOURCE_DIR}/*.cpp)
add_library(${PROJECT_NAME} STATIC ${CURRENT_FILE})
target_include_directories(${PROJECT_NAME} PUBLIC ${HEADPATH})

target_link_directories(${PROJECT_NAME} PRIVATE ${LIBPATH})
以下是Entity.cpp中的内容：
#include "Entity.h"
#include "Bullet.h"
#include "Event/EventFWD.h"
#include "ResourceManager.h"
#include <algorithm>
#include <memory>
#include "Event/EventSystem.h"
extern "C"{
	#include "raylib.h"
}

void updateBulletPool(std::vector<std::unique_ptr<Bullet>>& pool,const float deltaTime,Entity& shooter);
void tryFire(Entity& aEntity,const float deltaTime);
void updateCollision(std::vector<std::unique_ptr<Bullet>>& pool,const float deltaTime,Entity& shooter);
bool triggerHPThreshold(const int hp,const int maxHP);
Entity::Entity(const std::string texPath,const Vector2& pos,const int hp,const float interval,const int MAXenergy,const int rise,const std::vector<Bullet>& pattern)
		:position(pos),maxHP(hp),attackInterval(interval),
		 attackTimer(0),energy(0),maxEnergy(MAXenergy),energyRise(rise),
		 bulletIndex(0),bulletPattern(pattern),currentHP(hp),
		 bulletPool{}{
			texture=ResourceManager::Get().loadTexture(texPath);
			if(!IsTextureValid(texture)){
				//当加载不成功时，使用临时图标
				TraceLog(LOG_WARNING, "Using fallback texture for: %s",texPath.c_str());
				texture=ResourceManager::Get().loadTexture(ASSETS_IMAGE_PATH "/fallback.png");
			}
			boxCollider={position.x,position.y,(float)texture.width,(float)texture.height};
		 }
void Entity::reset(){
	currentHP=maxHP;
	energy=0;
	bulletIndex=0;
	bulletPool.clear();
}
void Entity::fire(Vector2 pos){
	if(bulletPattern.empty()){
		return;
	}
	if(pos.x==0&&pos.y==0){
		pos.x=position.x;
		pos.y=position.y;
	}
	bulletPool.push_back(bulletPattern[bulletIndex].shoot(pos));
	bulletIndex=(bulletIndex+1) % bulletPattern.size();
	addEnergy(energyRise);
	EventSystem::Get().broadcastEvent(Occasion::OnShoot,*this);
}
void Entity::fireBlast(){
	bulletPool.push_back(blast.shoot(position));
	resetEnergy();
	EventSystem::Get().broadcastEvent(Occasion::OnBlastShoot,*this);
}
void Entity::addRelic(std::shared_ptr<RelicEffect> relic){
	relics.push_back(std::move(relic));
	EventSystem::Get().bindRelicAndEvent(relics.back());
}
void Entity::takeDamage(const int damage){
	currentHP=std::max(0,currentHP-damage);
	if(triggerHPThreshold(currentHP, maxHP)){
		EventSystem::Get().broadcastEvent(Occasion::OnHPThreshold, *this);
	}
}
bool triggerHPThreshold(const int hp,const int maxHP){
	if(hp==maxHP*0.75){
		return true;
	}else if(hp==maxHP/2){
		return true;
	}else if(hp==maxHP/3){
		return true;
	}else if(hp==maxHP/4){
		return true;
	}
	return false;
}
/*--------------------------------------------------*/
void Player::Update(const float deltaTime){
	tryFire(*this, deltaTime);
	updateBulletPool(bulletPool, deltaTime,*this);
	Draw();
}
void Player::Draw() const {
	DrawTextureV(texture,position,WHITE);
	drawHPandEnergy();
	DrawRectangleLinesEx(boxCollider,5,RED);
}
void Player::drawHPandEnergy() const{
	DrawRectangleLines(0, GetScreenHeight()-40, int(GetScreenWidth()/2), 40, BLACK);
	DrawRectangle(0, GetScreenHeight()-40, int((float(currentHP)/maxHP)*(float(GetScreenWidth())/2)), 40, RED);
	DrawRectangleLines(int(GetScreenWidth()/2), GetScreenHeight()-40, int(GetScreenWidth()/2), 40, BLACK);
	DrawRectangle(int(GetScreenWidth()/2), GetScreenHeight()-40, int((float(energy)/maxEnergy)*(float(GetScreenWidth())/2)), 40, ORANGE);	
}
/*--------------------------------------------------*/
void Enemy::Update(const float deltaTime){
	tryFire(*this, deltaTime);
	updateBulletPool(bulletPool, deltaTime,*this);
	Draw();
}
void tryFire(Entity& shooter,const float deltaTime){
	float& attackTimer=shooter.getAttackTimer();
	float& attackInterval=shooter.getAttackInterVale();
	attackTimer+=deltaTime;
	if(shooter.getEnergy()==shooter.getMaxEnergy()){
		shooter.fireBlast();
	}	
	if(attackTimer>=attackInterval){
		shooter.fire();
		attackTimer=0;
	}
	EventSystem::Get().broadcastEvent(Occasion::OnShoot,shooter);
}

void updateBulletPool(std::vector<std::unique_ptr<Bullet>>& pool,const float deltaTime,Entity& shooter){
	for(auto it=pool.begin();it!=pool.end();){
		(*it)->Update(deltaTime,shooter);
		if((*it)->shouldBeRemoved()){
			it=pool.erase(it);
		}else{
			++it;
		}
	}	
}
void Enemy::Draw() const {
	DrawTextureV(texture,position,WHITE);
	drawHPandEnergy();
	DrawRectangleLinesEx(boxCollider,5,RED);
}
void Enemy::drawHPandEnergy() const{
	DrawRectangleLines(0, 0, int(GetScreenWidth()/2), 40, BLACK);
	DrawRectangle(0, 0, int((float(currentHP)/maxHP)*(float(GetScreenWidth())/2)), 40, RED);
	DrawRectangleLines(int(GetScreenWidth()/2), 0, int(GetScreenWidth()/2), 40, BLACK);
	DrawRectangle(int(GetScreenWidth()/2), 0, int((float(energy)/maxEnergy)*(float(GetScreenWidth())/2)), 40, ORANGE);	
}


以下是main.cpp中的内容：
#ifndef ASSETS_IMAGE_PATH
#define ASSETS_IMAGE_PATH
#include <exception>
#endif

extern "C" {
	#include "raylib.h"
}
#include <fstream>
#include "Effect/EffectManager.h"
#include "Event/EventSystem.h"
#include "DataManager.h"
#include "GameStageFwd.h"
#include "ResourceManager.h"
#include "GameStage.h"

const int WindowWidth=1280;
const int WindowHeight=720;

const Vector2 playerPos={640,500};
const Vector2 enemyPos={640,100};
const Vector2 playerVel={0,-1};
const Vector2 enemyVel={0,1};
using playerPtr=std::unique_ptr<Player>;
using enemyPtr=std::unique_ptr<Enemy>;

void RegisterEffects();
void entityInit(std::unique_ptr<Player>&&,std::unique_ptr<Enemy>&&);
bool shouldEnd();
int main(void){
	RegisterEffects();
	InitWindow(WindowWidth,WindowHeight,"SuperKLF");
	StageController& gameCTRL=StageController::Get();
	ResourceManager& resMgr=ResourceManager::Get();
	EventSystem& eventSys=EventSystem::Get();
	std::unique_ptr<Player> player;
	std::unique_ptr<Enemy> enemy;
	entityInit(std::move(player), std::move(enemy));
	SetTargetFPS(180);
	gameCTRL.transitionTo(GameStage::Battle);
	while(!shouldEnd()){
		BeginDrawing();
		ClearBackground(WHITE);
		DrawFPS(0, 0);
		gameCTRL.update();
		EndDrawing();
	}
	resMgr.cleanUp();
	CloseWindow();
}
void RegisterEffects(){
	std::ifstream file(DATA::EFFECT_PATH);
	nlohmann::json effects=nlohmann::json::parse(file);
	EffectManager::Get().loadEffects(effects);
}
bool shouldEnd(){
	if(WindowShouldClose()){return true;}
	if(StageController::Get().getCurrentStage()==GameStage::Exit){
		return true;
	}
	return false;
}

void entityInit(std::unique_ptr<Player>&& player,std::unique_ptr<Enemy>&& enemy){
	player.reset(new Player( ASSETS_IMAGE_PATH"player.png",playerPos,10,0.1,100,10));
	enemy.reset(new Enemy { ASSETS_IMAGE_PATH"enemy.png",enemyPos});
	player->setOpponent(*enemy);
	player->addBullet(Bullet( ASSETS_IMAGE_PATH"pen.png",playerVel));
	player->setBlast(Blast( ASSETS_IMAGE_PATH"warning.png",playerVel));
	enemy->setOpponent(*player);
	enemy->addBullet({ ASSETS_IMAGE_PATH"pen.png"});
	StageController::Get().bindEntities(std::move(player),std::move(enemy));	
	TraceLog(LOG_INFO,"Entities initialed");
}
以下是CMakeLists.txt中的内容：
#这是./src/Managers中的CMakeLists.txt
cmake_minimum_required(VERSION 3.5.0)
project(Managers)
add_subdirectory(${SRC}/Managers/ResourceManager)
add_subdirectory(${SRC}/Managers/GameStage)
add_subdirectory(${SRC}/Managers/Data)
以下是CMakeLists.txt中的内容：
#Data中的CMakeLists.txt
cmake_minimum_required(VERSION 3.5.0)
#每个依赖库的名字
project(Data)
file(GLOB CURRENT_FILE ${PROJECT_SOURCE_DIR}/*.cpp)
add_library(${PROJECT_NAME} STATIC ${CURRENT_FILE})
target_include_directories(${PROJECT_NAME} PUBLIC ${HEADPATH})

target_link_directories(${PROJECT_NAME} PRIVATE ${LIBPATH})
以下是DataManager.cpp中的内容：
#include "DataManager.h"
#include "RewardSystem.h"
#include "nlohmann/json.hpp"
#include <fstream>
#include <string>
extern "C"{
	#include "raylib.h"
}

using json= nlohmann::json;
const int DataManager::getCoinsEarned() const{
	return DATA::BASIC_COINS_EARNED*DATA::BASIC_COINS_RATE*passedLevel;
}
DataManager::DataManager(){
	//用nlohmann json从data.json中读取存档信息等
	//从rewards.json读取可用奖励
	if(FileExists(DATA::REWARD_CONFIG_PATH.c_str())){
		std::ifstream file{DATA::REWARD_CONFIG_PATH};
		json data=json::parse(file);
		rewards.reserve(data.size());
		for(auto& item :data){
			rewards.push_back({item});
			TraceLog(LOG_INFO, "[RES] Reward Loaded: %s",item["name"].get<std::string>().c_str());
		}
	}
}

const Reward& DataManager::getReward(const int i){
	return rewards.at(i);
}
以下是CMakeLists.txt中的内容：
#StageController中的CMakeLists.txt
cmake_minimum_required(VERSION 3.5.0)
#每个依赖库的名字
project(GameStage)
file(GLOB CURRENT_FILE ${PROJECT_SOURCE_DIR}/*.cpp)
add_library(${PROJECT_NAME} STATIC ${CURRENT_FILE})
target_include_directories(${PROJECT_NAME} PUBLIC ${HEADPATH})

target_link_directories(${PROJECT_NAME} PRIVATE ${LIBPATH})
以下是GameStage.cpp中的内容：
#include "DataManager.h"
#include "Entity.h"
#include "Event/EventFWD.h"
#include "Event/EventSystem.h"
extern "C"{
	#include "raylib.h"
}
#include "GameStageFwd.h"
#include "GameStage.h"
#include "UI.h"
#include "Collision.h"

using Collision::checkIsTouchButton;


void responseToSignalFromDefeat(const EventSignal signal);
void drawDefeatScreen(const DefeatUI& ui);
const GameStage checkBattleStage(const Player& player,const Enemy& enemy);

StageController::StageController(){
	currentStage=GameStage::MainMenu;
	signal=EventSignal::IDLE;
	player=nullptr;
	enemy=nullptr;
}
void StageController::resetGame(){
	if(player==nullptr||enemy==nullptr){return;}
	player->reset();
	enemy->reset();
	DataManager::Get().reset();
}
void StageController::update(){
	switch(currentStage){
		case(GameStage::MainMenu):
		mainMenuUpdate();
		break;
		case(GameStage::Battle):
		battleUpdate();
		break;
		case(GameStage::Victory):
		victoryUpdate();
		break;
		case(GameStage::Defeat):
		defeatUpdate();
		break;
		case(GameStage::NextLevel):
		nextLevel();
		break;
		case(GameStage::Pause):
		pauseUpdate();
		break;
		case(GameStage::Exit):
		break;
	}	
}
void StageController::beginBattle(){
	EventSystem::Get().broadcastEvent(Occasion::OnBattleStart,*player);
	EventSystem::Get().broadcastEvent(Occasion::OnBattleStart, *enemy);
	player->reset();
	enemy->reset();
}
void StageController::battleUpdate(){
	static bool newBattle=false;
	if(newBattle){
		beginBattle();
		newBattle=false;
	}
	float deltaTime=GetFrameTime();
	player->Update(deltaTime);
	enemy->Update(deltaTime);
	currentStage=checkBattleStage(*player, *enemy);
	if(currentStage==GameStage::Defeat){
		TraceLog(LOG_INFO, "[GameSystem] Battle Defeated");
	}else if(currentStage==GameStage::Victory){
		TraceLog(LOG_INFO, "[GameSystem] Battle Victory");
	}
	if(currentStage!=GameStage::Battle&&currentStage!=GameStage::Pause){
		newBattle=true;
	}
}
const GameStage checkBattleStage(const Player& player,const Enemy& enemy){
	if(!player.isAlive()){return GameStage::Defeat;}
	if(!enemy.isAlive()){return GameStage::Victory;}
	return GameStage::Battle;
}
void StageController::defeatUpdate(){
	DefeatUI& ui=DefeatUI::Get();
	ui.Draw();
	if(IsKeyPressed(KEY_SPACE)){
		responseToSignalFromDefeat(EventSignal::RESTART);
		return;
	}
	if(checkIsTouchButton(ui.getRestartBtn())){
		if(IsMouseButtonPressed(MOUSE_BUTTON_LEFT)){
			responseToSignalFromDefeat(EventSignal::RESTART);
		}
	}
	if(checkIsTouchButton(ui.getExitBtn())){
		if(IsMouseButtonPressed(MOUSE_LEFT_BUTTON)){
			responseToSignalFromDefeat(EventSignal::EXIT);
		}
	}
}
void responseToSignalFromDefeat(const EventSignal signal){
	StageController& ctrl=StageController::Get();
	switch(signal){
		case(EventSignal::RESTART):
		ctrl.resetGame();
		ctrl.transitionTo(GameStage::Battle);
		TraceLog(LOG_INFO, "[GameSystem] Restart game");
		break;
		case(EventSignal::EXIT):
		ctrl.transitionTo(GameStage::MainMenu);
		TraceLog(LOG_INFO, "[GameSystem] Return to main menu");
		break;
		case(EventSignal::IDLE):
		break;
	}
}
void StageController::victoryUpdate(){
	VictoryUI& ui=VictoryUI::Get();
	if(DataManager::Get().getRefreshTimes()==0){
		ui.tryGenerateRewards(*player);
	}
	ui.Draw();
	if(checkIsTouchButton(ui.getRefreshBtn())){
		if(IsMouseButtonPressed(MOUSE_LEFT_BUTTON)){
			ui.tryGenerateRewards(*player);
		}
	}
	for(int i=0;i<3;i++){
		if(checkIsTouchButton(ui.getRewardBtn(i))){
			if(IsMouseButtonPressed(MOUSE_BUTTON_LEFT)){
				ui.chooseReward(i,*player);
				currentStage=GameStage::NextLevel;
			}
		}
	}
}
void StageController::nextLevel(){
	TraceLog(LOG_INFO,"[GameSystem] Advancing to next Level");
	TraceLog(LOG_WARNING,"Next level has not been developed yet");
	transitionTo(GameStage::Battle);
}
void StageController::pauseUpdate(){

}
void StageController::mainMenuUpdate(){
	transitionTo(GameStage::Exit);
}
以下是CMakeLists.txt中的内容：
#ResourceManager中的CMakeLists.txt
cmake_minimum_required(VERSION 3.5.0)
#每个依赖库的名字
project(ResourceManager)
file(GLOB CURRENT_FILE ${PROJECT_SOURCE_DIR}/*.cpp)
add_library(${PROJECT_NAME} STATIC ${CURRENT_FILE})
target_include_directories(${PROJECT_NAME} PUBLIC ${HEADPATH})

target_link_directories(${PROJECT_NAME} PRIVATE ${LIBPATH})
以下是ResourceManager.cpp中的内容：
#include <string>
extern "C"{
	#include "raylib.h"
}

#include "ResourceManager.h"

const Texture2D& ResourceManager::loadTexture(const std::string path){
	if(textures.find(path)!=textures.end()){
		return textures[path];
	}
	if(!FileExists(path.c_str())){
		TraceLog(LOG_ERROR,"[RES] Texture not find: %s",path.c_str());
		return textures[""];
	}
	Texture2D tex=LoadTexture(path.c_str());
	if(!IsTextureValid(tex)){
		TraceLog(LOG_ERROR, "[RES] Failed to load: %s",path.c_str());
		return textures[""];
	}
	textures[path]=tex;
	TraceLog(LOG_INFO, "[RES] Loaded: %s (%d x %d)",path.c_str(),tex.width,tex.height);
	return textures[path];
}


std::string ResourceManager::resizeTexture(const std::string path,const int width,const int height){
	if(textures.find(path)==textures.end()){return "";}
	static int ID=0;
	Image img=LoadImageFromTexture(textures[path]);
	ImageResize(&img,width,height);
	std::string processedPath=path+"_porcessed"+std::to_string(ID);
	textures[processedPath]=LoadTextureFromImage(img);
	UnloadImage(img);
	ID++;
	return processedPath;
}

void ResourceManager::unloadTexture(const std::string path){
	if(textures.find(path)!=textures.end()){
		UnloadTexture(textures[path]);
		textures.erase(path);
		TraceLog(LOG_INFO, "[RES] Unloaded: %s",path.c_str());
	}
}

const Font& ResourceManager::loadFont(){
	if(isFontAssigned){return font;}
	if(UI::FONT_PATH==""){
		font=GetFontDefault();
	}else{
		font=LoadFont(UI::FONT_PATH.c_str());
	}
	return font;
}
void ResourceManager::cleanUp(){
	for(auto& [path,tex]:textures){
		UnloadTexture(tex);
	}
	textures.clear();
	UnloadFont(font);
	TraceLog(LOG_INFO, "[RES] All resources released");
}

以下是CMakeLists.txt中的内容：
#RewardSystem中的CMakeLists.txt
cmake_minimum_required(VERSION 3.5.0)
#每个依赖库的名字
project(RewardSystem)
file(GLOB CURRENT_FILE ${PROJECT_SOURCE_DIR}/*.cpp)
add_library(${PROJECT_NAME} STATIC ${CURRENT_FILE})
target_include_directories(${PROJECT_NAME} PUBLIC ${HEADPATH})

target_link_directories(${PROJECT_NAME} PRIVATE ${LIBPATH})
以下是RewardSystem.cpp中的内容：
#include "RewardSystem.h"
#include "Effect/EffectManager.h"
#include "Effect/InstantEffect.h"
#include "Entity.h"
#include <memory>
#include <random>
#include <string>
#include "ResourceManager.h"
#include <cctype>

std::string autoSplit(const std::string&);
std::string transRelicIDToName(const std::string&);

Reward::Reward(const nlohmann::json& reward){
	name=reward["name"].get<std::string>();
	description=autoSplit(reward["description"].get<std::string>());
	icon=ResourceManager::Get().loadTexture(reward["icon_path"].get<std::string>());
	effect=EffectManager::Get().getInstantEffect(reward["effectID"].get<std::string>());
	if(name=="NewRelic"){
		std::random_device rd;
		std::mt19937 gen(rd());
		std::uniform_int_distribution<> dis(0,EffectManager::Get().getRelicEffectMap().size()-1);
		int randomIndex=dis(gen);
		std::string relic_id=EffectManager::Get().getRelicEffectMap().at(randomIndex);
		std::dynamic_pointer_cast<NewRelic>(effect)->setRelicID(relic_id);
		std::string relic_name=transRelicIDToName(relic_id);
		name="Relic: "+relic_name;
		description=autoSplit(reward["description"].get<std::string>()+relic_name);
		icon=ResourceManager::Get().loadTexture(ASSETS_IMAGE_PATH+relic_id+".png");
	}
}

std::string autoSplit(const std::string& str){
	std::string newStr;
	for(int i=0;i<str.length();i++){
		newStr+=str[i];
		if(i%26==0&&i!=0&&str[i]!='\n'){
			newStr+='\n';
		}
	}
	newStr+='\0';
	return newStr;
}
void Reward::apply(Player& player){
	effect->onApply(player);
}

std::string transRelicIDToName(const std::string& id){
	std::string name=id;
	for(auto it=name.begin();it!=name.end();it++){
		if(*(it-1)=='_'||it==name.begin()){
			*it=std::toupper(*it);
		}
		if(*it=='_'){
			it=name.erase(it);
		}
	}
	return name;
}


以下是BulletEffect.cpp中的内容：
#include "Effect/BulletEffect.h"
#include "Entity.h"
void GiveDamage::tryTrigger(Entity& shooter,const Occasion& timing){
	if(timing==Occasion::OnHit){
		shooter.getOpponent().takeDamage(damage);
	}
}
以下是CMakeLists.txt中的内容：
#SpecialEffect中的CMakeLists.txt
cmake_minimum_required(VERSION 3.5.0)
#每个依赖库的名字
project(SpecialEffect)
file(GLOB CURRENT_FILE ${PROJECT_SOURCE_DIR}/*.cpp)
add_library(${PROJECT_NAME} STATIC ${CURRENT_FILE})
target_include_directories(${PROJECT_NAME} PUBLIC ${HEADPATH})
target_link_directories(${PROJECT_NAME} PRIVATE ${LIBPATH})
以下是EffectManager.cpp中的内容：
#include "Effect/EffectManager.h"
#include "Effect/InstantEffect.h"
#include "Effect/InstantEffectFactory.h"
#include "Effect/RelicEffect.h"
#include "Effect/RelicEffectFactory.h"
#include <memory>
#include <raylib.h>
#include <string>
using json = nlohmann::json;
//InstantEffectFactory的分派函数
void GenInstantEffectFactory(std::unique_ptr<InstantEffectFactory>& f,std::string id);
//RelicEffectFactory的分派函数
void GenRelicEffectFactory(std::unique_ptr<RelicEffectFactory>& f,std::string id);

bool EffectManager::isRelicEffectLoaded(const std::string& id) const{
    return RelicEffectLoader::Get().isEffectLoaded(id);
}
bool EffectManager::isInstantEffectLoaded(const std::string& id)const{
    return InstantEffectLoader::Get().isEffectLoaded(id);
}
void EffectManager::loadEffects(const json& json) {
    try {
        if (json.contains("InstantEffects")) {
            instantIDs=InstantEffectLoader::Get().loadInstantEffect(json["InstantEffects"]);
        } else {
            TraceLog(LOG_WARNING, "No InstantEffects found in JSON");
        }

        if (json.contains("RelicEffects")) {
            relicIDs=RelicEffectLoader::Get().loadRelicEffect(json["RelicEffects"]);
        } else {
            TraceLog(LOG_WARNING, "No RelicEffects found in JSON");
        }
    } catch (const std::exception& e) {
        TraceLog(LOG_ERROR, "Failed to load effects: %s", e.what());
    }
}

std::shared_ptr<InstantEffect> EffectManager::getInstantEffect(const std::string& id) const {
    TraceLog(LOG_INFO, "Getting InstantEffect [id: %s]",id.c_str());
    return InstantEffectLoader::Get().getEffect(id);
}
std::shared_ptr<InstantEffect> EffectManager::getInstantEffect(const int index)const{
    return getInstantEffect(instantIDs.at(index));
}
std::shared_ptr<RelicEffect> EffectManager::getRelicEffect(const std::string& id) const {
    TraceLog(LOG_INFO, "Getting RelicEffect [id: %s]",id.c_str());
    return RelicEffectLoader::Get().getEffect(id);
}
std::shared_ptr<RelicEffect> EffectManager::getRelicEffect(const int index)const{
    return getRelicEffect(relicIDs.at(index));
}
std::map<int,std::string> InstantEffectLoader::loadInstantEffect(const json& effects) {
    std::map<int,std::string> EffectIDs={{0," "}};
    int index=1;
    for (const auto& effect : effects) {
        try {
            std::string id = effect["id"].get<std::string>();
            std::unique_ptr<InstantEffectFactory> factory;
            GenInstantEffectFactory(factory, id);
            factory->loadFromJson(effect["params"]);
            factories[id] = std::move(factory);
            TraceLog(LOG_INFO, "Loaded InstantEffect: %s", id.c_str());
            EffectIDs[index]=id;
            index++;
        } catch (const std::exception& e) {
            TraceLog(LOG_ERROR, "Failed to load InstantEffect: %s", e.what());
        }
    }
    if(factories.find(" ")==factories.end()){
        std::unique_ptr<InstantEffectFactory> f;
        GenInstantEffectFactory(f," ");
        factories[" "]=std::move(f);
    }
    return EffectIDs;
}
void GenInstantEffectFactory(std::unique_ptr<InstantEffectFactory>& f,std::string id){
    if(id=="speed_boost"){
        f=std::make_unique<ConcreteInstantEffectFactory<SpeedBoost>>();
    }else if(id=="health_boost"){
        f=std::make_unique<ConcreteInstantEffectFactory<HealthBoost>>();
    }else if(id=="new_relic"){
        f=std::make_unique<ConcreteInstantEffectFactory<NewRelic>>();
    }
    else{
        f=std::make_unique<ConcreteInstantEffectFactory<NullInstantEffect>>();
    }
}

std::shared_ptr<InstantEffect> InstantEffectLoader::getEffect(const std::string& id) {
    if(factories.find(id)==factories.end()){
        TraceLog(LOG_ERROR,"Instant effect of %s not exist",id.c_str());
        return factories[" "]->create(); 
    }
    return factories[id]->create();
}

bool InstantEffectLoader::isEffectLoaded(const std::string& id)const{
    if(factories.find(id)!=factories.end()){return true;}
    return false;
}

std::map<int,std::string> RelicEffectLoader::loadRelicEffect(const json& relics) {
    std::map<int,std::string> EffectIDs={{0," "}};
    std::string id, type;
    int index=1;
    for (const auto& relic : relics) {
        try {
            id = relic["id"].get<std::string>();
            std::unique_ptr<RelicEffectFactory> factory;
            GenRelicEffectFactory(factory, id);
            factory->loadFromJson(relic["params"]);
            factories[id] = std::move(factory);
            TraceLog(LOG_INFO, "Loaded RelicEffect: %s", id.c_str());
            EffectIDs[index]=id;
            index++;
        } catch (const std::exception& e) {
            TraceLog(LOG_ERROR, "Failed to load RelicEffect: %s", e.what());
        }
    }
    if(factories.find(" ")==factories.end()){
        std::unique_ptr<RelicEffectFactory> f;
        GenRelicEffectFactory(f," ");
        factories[" "]=std::move(f);
    }
    return EffectIDs;
}
void GenRelicEffectFactory(std::unique_ptr<RelicEffectFactory>& f,std::string id){
    if(id=="double_shoot_relic"){
       f=std::make_unique<ConcreteRelicFactory<DoubleShootRelic>>(); 
    }
    else{
       f=std::make_unique<ConcreteRelicFactory<NullRelicEffect>>(); 
    }
}

bool RelicEffectLoader::isEffectLoaded(const std::string& id) const{
    if(factories.find(id)!=factories.end()){return true;}
    return false;
}


std::shared_ptr<RelicEffect> RelicEffectLoader::getEffect(const std::string& id) {
    if(factories.find(id)==factories.end()){
        TraceLog(LOG_ERROR,"Relic effect of %s not exist",id.c_str());
        return factories[" "]->create();
    }
    return factories[id]->create();
}
以下是InstantEffect.cpp中的内容：
#include "Effect/InstantEffect.h"
#include "Effect/EffectManager.h"
#include "Entity.h"
#include <string>

SpeedBoost::SpeedBoost(const nlohmann::json& params):InstantEffect(){
	rate=params["rate"].get<float>();
}
void SpeedBoost::onApply(Player& player)const{
	player.setAttackInterval(rate);
}

HealthBoost::HealthBoost(const nlohmann::json& params):InstantEffect(){
	if(params["value"].is_number_float()){
		value=params["value"].get<float>();
	}else{
		value=params["value"].get<int>();
	}
}
void HealthBoost::onApply(Player& player)const{
	const int* intPtr=std::get_if<int>(&value);
	if(intPtr!=nullptr){
		player.MaxHealthBoost(*intPtr);
	}else{
		player.MaxHealthBoost(*(std::get_if<float>(&value)));
	}
}

NewRelic::NewRelic(const nlohmann::json& params):InstantEffect(){
	relic_id="null_relic_effect";
}
void NewRelic::onApply(Player& player)const{
	if(relic_id=="null_relic_effect"){
		TraceLog(LOG_ERROR,"creating a new relic with default id!");
		return;
	}else{
		if(EffectManager::Get().isRelicEffectLoaded(relic_id)){
			player.addRelic(EffectManager::Get().getRelicEffect(relic_id));
		}else{
			TraceLog(LOG_ERROR, "creating a new relic with unknown id: %s",relic_id.c_str());
		}
	}
}
void NewRelic::setRelicID(const std::string& id){
	relic_id=id;
}
以下是RelicEffect.cpp中的内容：
#include "Effect/RelicEffect.h"
#include "Entity.h"

DoubleShootRelic::DoubleShootRelic(const nlohmann::json& params):RelicEffect(){
	description=params["description"].get<std::string>();
}
void DoubleShootRelic::onTrigger(Entity& relatedEntity){
	TraceLog(LOG_WARNING,"Triggering DoubleShootRelic(Not developed yet)");
}
以下是CMakeLists.txt中的内容：
#UI中的CMakeLists.txt
cmake_minimum_required(VERSION 3.5.0)
#每个依赖库的名字
project(UI)
file(GLOB CURRENT_FILE ${PROJECT_SOURCE_DIR}/*.cpp)
add_library(${PROJECT_NAME} STATIC ${CURRENT_FILE})
target_include_directories(${PROJECT_NAME} PUBLIC ${HEADPATH})

target_link_directories(${PROJECT_NAME} PRIVATE ${LIBPATH})
add_subdirectory(${SRC}/UI/UIComponent)
以下是CMakeLists.txt中的内容：
#UI中的CMakeLists.txt
cmake_minimum_required(VERSION 3.5.0)
#每个依赖库的名字
project(UIComponent)
file(GLOB CURRENT_FILE ${PROJECT_SOURCE_DIR}/*.cpp)
add_library(${PROJECT_NAME} STATIC ${CURRENT_FILE})
target_include_directories(${PROJECT_NAME} PUBLIC ${HEADPATH})

target_link_directories(${PROJECT_NAME} PRIVATE ${LIBPATH})
以下是UIComponent.cpp中的内容：
#include "UIComponent.h"
#include "ResourceManager.h"
#include "Collision.h"
extern "C"{
    #include "raylib.h"
}
const bool isButtonPressed(const Button& btn);
const bool isButtonHovered(const Button& btn);

const float UI::countTextPosX(const std::string& str,const int origin,const int fontSize,const int offset){
	float posX=origin;
	const Font& font=ResourceManager::Get().loadFont();
	posX-=MeasureTextEx(font, str.c_str(), fontSize, 1).x/2-offset;
	return posX;
}	


Button::Button(Rectangle r, std::string t, Color c) {
    rect = r;
    text = t;
    color = c;
	resetPosAndSize();
}
void Button::resetPosAndSize(){
    const float maxTextWidth = rect.width * UI::WIDTH_RADIO;
    const float maxTextHeight = rect.height * UI::HEIGHT_RADIO;
	const Font& font=ResourceManager::Get().loadFont();
    int low = UI::MIN_FONT_SIZE;
    int high = int(maxTextHeight);
    int bestSize = UI::MIN_FONT_SIZE;
    while (low <= high) {
        int mid = (low + high) / 2;
        Vector2 textSize = MeasureTextEx(font, text.c_str(), mid, 1);
        if (textSize.x <= maxTextWidth) {
            bestSize = mid;
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }
    fontSize = bestSize;
	Vector2 textSize=MeasureTextEx(font, text.c_str(), fontSize, 1);
    textPos = {
		UI::countTextPosX(text, rect.x, fontSize,(rect.width/2)),
        rect.y + (rect.height -textSize.y)/2
    };	
}

void Button::Draw() const{
	Color drawColor =color;
	const Font& font=ResourceManager::Get().loadFont();
	if(available){
		if(isButtonPressed(*this)){
			drawColor=ColorBrightness(color, -0.3f);
		}else if(isButtonHovered(*this)){
			drawColor=ColorBrightness(color, -0.15f);
		}
	}else{
		drawColor=DARKGRAY;
	}
	DrawRectangleRec(rect, drawColor);
	BeginScissorMode(rect.x, rect.y, rect.width, rect.height);
	DrawTextEx(font, text.c_str(), textPos, fontSize, 1, WHITE);
	EndScissorMode();
}
void ButtonWithExplain::Draw() const{
	Button::Draw();
	if(isButtonHovered(*this)&&available){
        DrawExplain();
	}  
}
void ButtonWithExplain::DrawExplain() const{
    Rectangle explainBox={
        rect.x,rect.y+rect.height,rect.width,rect.height*2.5f
    };
    DrawRectangleRec(explainBox, ColorBrightness(color, 0.15f));
    Vector2 position={explainBox.x,explainBox.y};
    DrawTextEx(ResourceManager::Get().loadFont(), explain.c_str(), position, UI::EXPLAIN_FONTSIZE, 1, WHITE);
}

void ButtonWithNumber::Draw() const{
	Color drawColor =color;
	const Font& font=ResourceManager::Get().loadFont();
	if(available){
		if(isButtonPressed(*this)){
			drawColor=ColorBrightness(color, -0.3f);
		}else if(isButtonHovered(*this)){
			drawColor=ColorBrightness(color, -0.15f);
		}
	}else{
		drawColor=DARKGRAY;
	}
	DrawRectangleRec(rect, drawColor);
	BeginScissorMode(rect.x, rect.y, rect.width, rect.height);
	DrawTextEx(font, (text+addition).c_str(), textPos, fontSize, 1, WHITE);
	EndScissorMode();
}

const bool isButtonPressed(const Button& btn){
	return isButtonHovered(btn)&&IsMouseButtonPressed(MOUSE_LEFT_BUTTON);
}
const bool isButtonHovered(const Button& btn){
	return Collision::checkIsTouchButton(btn);
}
以下是UI.cpp中的内容：
#include "UI.h"
#include "DataManager.h"
#include "Entity.h"
#include "RewardSystem.h"
#include "UIComponent.h"
#include <string>
#include <random>
extern "C"{
	#include "raylib.h"
}

void DefeatUI::Draw() const{
	ClearBackground(WHITE);
	const int screenHeight=GetScreenHeight();
	const int screenWidth=GetScreenWidth();	
	DrawRectangle(0, 0, screenWidth, screenHeight, Fade(BLACK,0.5f));
	std::string title="Mamba Out!";
	std::string subTitle=R"(You have passed %d levels!)";
	DrawText(title.c_str(),UI::countTextPosX(title,screenWidth/2,2*UI::FONTSIZE),200,2*UI::FONTSIZE,RED);
	DrawText(TextFormat(subTitle.c_str(),DataManager::Get().getPassedLevel()), UI::countTextPosX(subTitle, screenWidth/2, UI::FONTSIZE), 350, UI::FONTSIZE, RED);
	restartButton.Draw();
	exitButton.Draw();
}

DefeatUI::DefeatUI(){
	const int screenHeight=GetScreenHeight();
	const int screenWidth=GetScreenWidth();
	restartButton={
	{screenWidth/2.0f-UI::BASIC_BUTTON_WIDTH/2.0f,
		screenHeight*0.6f,
		UI::BASIC_BUTTON_WIDTH,
		UI::BASIC_BUTTON_HEIGHT},
	"[Space]Restart",ORANGE};
	exitButton={{
		screenWidth/2.0f-UI::BASIC_BUTTON_WIDTH/2.0f,
		screenHeight*0.75f,
		UI::BASIC_BUTTON_WIDTH,
		UI::BASIC_BUTTON_HEIGHT},
		"Quit",ORANGE};
}
VictoryUI::VictoryUI(){
	const int screenHeight=GetScreenHeight();
	const int screenWidth=GetScreenWidth();
	refreshBtn={{screenWidth/2.0f-UI::BASIC_BUTTON_WIDTH/2.0f,
		screenHeight*0.8f,
		UI::BASIC_BUTTON_WIDTH,
		UI::BASIC_BUTTON_HEIGHT},
		"Refresh",ORANGE};
	for(int i=0;i<3;i++){
		rewardBtn[i]={
			{GetScreenWidth()/5.0f*(i+2)-UI::BASIC_BUTTON_WIDTH,
			GetScreenHeight()*0.5f,
			UI::BASIC_BUTTON_WIDTH,
			UI::BASIC_BUTTON_HEIGHT},
			"Reward",ORANGE,"Explain"};
	}			
}
void VictoryUI::tryGenerateRewards(Player& player){
	bool success=player.deductMoney(DataManager::Get().getRefreshMoney());
	if(success){
		TraceLog(LOG_INFO,"Generating rewards");
		std::random_device rd;
		std::mt19937 gen(rd());
		std::uniform_int_distribution<> dis(0,DataManager::Get().getRewardSize()-1);
		currentRewards.clear();
		for(int i=0;i<3;i++){
			currentRewards.push_back(DataManager::Get().getReward(dis(gen)));
			rewardBtn[i].setText(currentRewards[i].getName());
			rewardBtn[i].setExplain(currentRewards[i].getDescription());
		}
		DataManager::Get().refreshTimesAdvance();
		if(player.getMoney()<=DataManager::Get().getRefreshMoney()){
			refreshBtn.setAvailibility(false);
		}else{
			refreshBtn.setAvailibility(true);
		}
		refreshBtn.setAddition("(-"+std::to_string(DataManager::Get().getRefreshMoney())+")");
	}
}
void VictoryUI::chooseReward(const int i,Player& player){
	TraceLog(LOG_INFO,"Choosing reward[%d]",i);
	DataManager::Get().resetRefreshTimes();
	Reward reward=currentRewards[i];
	reward.apply(player);
}

void VictoryUI::Draw() const{
	ClearBackground(WHITE);
	const int screenHeight=GetScreenHeight();
	const int screenWidth=GetScreenWidth();
	DrawRectangle(0, 0, screenWidth, screenHeight, Fade(BLACK,0.5f));
	std::string subTitle=R"(You passed %d levels!)";
	DrawText(TextFormat(subTitle.c_str(),DataManager::Get().getPassedLevel()), UI::countTextPosX(subTitle, screenWidth/2, 2*UI::FONTSIZE), 200, 2*UI::FONTSIZE, RED);
	for(int i=0;i<3;i++){
		rewardBtn[i].Draw();
	}
	refreshBtn.Draw();
}
