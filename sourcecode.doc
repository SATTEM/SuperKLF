目前项目结构：
.
├── CMakeLists.txt
├── idea
├── include
│   ├── Bullet.h
│   ├── Collision.h
│   ├── DataManager.h
│   ├── Effect
│   │   ├── BulletEffect.h
│   │   ├── EffectManager.h
│   │   ├── InstantEffectFactory.h
│   │   ├── InstantEffect.h
│   │   ├── RelicEffectFactory.h
│   │   └── RelicEffect.h
│   ├── Entity.h
│   ├── EventSystem.h
│   ├── GameStageFwd.h
│   ├── GameStage.h
│   ├── nlohmann
│   │   ├── json_fwd.hpp
│   │   └── json.hpp
│   ├── raylib
│   │   ├── raylib.h
│   │   ├── raymath.h
│   │   ├── rcamera.h
│   │   └── rlgl.h
│   ├── ResourceManager.h
│   ├── RewardSystem.h
│   ├── UIComponent.h
│   └── UI.h
├── libs
│   ├── libCollision.a
│   ├── libData.a
│   ├── libEffectManager.a
│   ├── libEntity.a
│   ├── libGameStage.a
│   ├── libraylib.so
│   ├── libResourceManager.a
│   ├── libRewardSystem.a
│   ├── libSpecialEffect.a
│   ├── libStageController.a
│   ├── libUI.a
│   └── libUIComponent.a
├── outline
├── res
│   ├── data
│   │   ├── Effects.json
│   │   └── rewards.json
│   ├── enemy.png
│   ├── fallback.png
│   ├── image
│   │   ├── attack_speed.png
│   │   ├── enemy.png
│   │   ├── exit.png
│   │   ├── fallback.png
│   │   ├── health_boost.png
│   │   ├── pen.png
│   │   ├── player.png
│   │   ├── restart.png
│   │   └── warning.png
│   ├── pen.png
│   ├── player.png
│   └── warning.png
├── sourcecode.doc
└── src
    ├── CMakeLists.txt
    ├── Collision
    │   ├── CMakeLists.txt
    │   └── Collision.cpp
    ├── Entity
    │   ├── Bullet.cpp
    │   ├── CMakeLists.txt
    │   └── Entity.cpp
    ├── main.cpp
    ├── Managers
    │   ├── CMakeLists.txt
    │   ├── Data
    │   │   ├── CMakeLists.txt
    │   │   └── DataManager.cpp
    │   ├── Effect
    │   │   ├── CMakeLists.txt
    │   │   └── EffectManager.cpp
    │   ├── GameStage
    │   │   ├── CMakeLists.txt
    │   │   └── GameStage.cpp
    │   └── ResourceManager
    │       ├── CMakeLists.txt
    │       └── ResourceManager.cpp
    ├── RewardSystem
    │   ├── CMakeLists.txt
    │   └── RewardSystem.cpp
    ├── SpecialEffect
    │   ├── BulletEffect.cpp
    │   ├── CMakeLists.txt
    │   └── InstantEffect.cpp
    └── UI
        ├── CMakeLists.txt
        ├── UIComponent
        │   ├── CMakeLists.txt
        │   └── UIComponent.cpp
        └── UI.cpp

21 directories, 80 files
以下是CMakeLists.txt中的内容：
#根目录CMakeLists.txt
cmake_minimum_required(VERSION 3.5.0)
project(SuperKLF)
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(SRC ${PROJECT_SOURCE_DIR}/src)
set(LIBPATH ${PROJECT_SOURCE_DIR}/libs)
set(GAMEPATH ${PROJECT_SOURCE_DIR}/bin)
set(HEADPATH ${PROJECT_SOURCE_DIR}/include)
#输出clangd要读取的配置
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)
#可执行文件的输出路径
set(EXECUTABLE_OUTPUT_PATH ${GAMEPATH})
#动态库输出路径
set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${LIBPATH})
#静态库输出路径
set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${LIBPATH})
file(COPY res DESTINATION ${GAMEPATH}/)
file(COPY config.json DESTINATION ${GAMEPATH}/)
add_compile_definitions(ASSETS_IMAGE_PATH="./res/image/")
add_compile_definitions(ASSETS_DATA_PATH="./res/data/")
add_subdirectory(${SRC}/Entity)
add_subdirectory(${SRC}/Collision)
add_subdirectory(${SRC}/UI)
add_subdirectory(${SRC}/SpecialEffect)
add_subdirectory(${SRC}/Managers)
add_subdirectory(${SRC}/RewardSystem)
add_subdirectory(${PROJECT_SOURCE_DIR}/src)
以下是Bullet.h中的内容：
#ifndef BULLET_H
#define BULLET_H

#include <vector>
extern "C"{
	#include "raylib.h"
}
#include <memory>
#include <string>
#include "Effect/BulletEffect.h"

class Entity;


namespace BULLET{
	//子弹
	const Vector2 BULLET_SIZE={240,240};
	const float BULLET_RADIUS=150.0f;
	//大招
	const float BLAST_DRAWSCALE=0.3f;
	//全局
	const int BASIC_SPEED=160 ;//基础速度，单位是每秒像素	
	const int BASIC_DMG=50;//基础伤害
}

//基础版本子弹，有子弹的基本功能，特效只有伤害
class Bullet{
private:
	Vector2 position;
	Texture2D texture;
	std::string texturePath;
	Vector2 velocity;//速度倍率
	float drawScale=0.1f;//子弹缩放倍率
	int damage;
	float colliderRadius;
	bool active;
	bool isOnShoot=true;
	bool shouldRemove=false;
	std::vector<std::shared_ptr<BulletEffect>> effects;

public:
	~Bullet()=default;
	Bullet():shouldRemove(true),active(false){/*默认子弹不会出现在场上*/}
	Bullet(const std::string texPath,const Vector2& vel={0,1},const Vector2& pos={0,0},const int dmg=BULLET::BASIC_DMG,const bool act=false);
	Bullet(const Bullet& proto,const Vector2& begin);

	std::unique_ptr<Bullet> shoot(const Vector2& begin);
	void Draw() const;
	void Update(const float deltaTime,Entity& shooter);
	void checkHit(Entity& shooter);
	void tryTriggerEffects(Entity& shooter,const Occasion& timing);
	void addEffect(std::shared_ptr<BulletEffect> effect){effects.push_back(std::move(effect));}
	void setDamage(const int dmg){damage=dmg;}
	void setDrawScale(const float val){drawScale=val;}
	void countColliderRadius(const Vector2 size=BULLET::BULLET_SIZE);
	const Vector2 getColliderCentre() const {return {position.x+int(texture.width*drawScale/2),position.y+int(texture.height*drawScale/2)};}
	const float getColliderRadius() const {return colliderRadius;}
	const bool shouldBeRemoved() const{return shouldRemove;}
};
class Blast:public Bullet{

public:
	Blast():Bullet(){}
	Blast(const std::string texPath,const Vector2& vel={0,1},const Vector2& pos={0,0},const int dmg=10*BULLET::BASIC_DMG,const bool act=false)
	:Bullet(texPath,vel,pos,dmg,act){
		setDrawScale(BULLET::BLAST_DRAWSCALE);
		countColliderRadius(BULLET::BULLET_SIZE);
	}
	Blast(const Blast& proto,const Vector2& begin):Bullet(*this,begin){}
};


#endif
以下是Collision.h中的内容：
#ifndef COLLISION_H
#define COLLISION_H

#include "Bullet.h"
#include "Entity.h"
#include "UIComponent.h"

namespace Collision{
	bool checkBulletEntity(const Bullet& aBullet,const Entity& aEntity);
	bool checkEntityEntity(const Entity& a,const Entity& b);
	bool checkIsTouchButton(const Button& aButton);
}

#endif

以下是DataManager.h中的内容：
#ifndef DATAMANAGER_H
#define DATAMANAGER_H
#include "RewardSystem.h"
#include <string>
#include <vector>

namespace DATA {
	const int BASIC_COINS_EARNED=100;
	const float BASIC_COINS_RATE=0.15f;
	const std::string LEVEL_CONFIG_PATH=ASSETS_DATA_PATH "levels.json";
	const std::string REWARD_CONFIG_PATH=ASSETS_DATA_PATH "rewards.json";
	const std::string DATA_PATH=ASSETS_DATA_PATH "data.json";
	const std::string EFFECT_PATH=ASSETS_DATA_PATH "Effects.json";
}

class DataManager{
private:
	int passedLevel=0;
	float rewardRefreshRate=1.f;
	int rewardRefreshBase=10;
	int refreshTimes=0;
	std::vector<Reward> rewards;
	DataManager();
	~DataManager()=default;
public:
	DataManager(const DataManager&)=delete;
	void operator=(const DataManager&)=delete;
	static DataManager& Get(){
		static DataManager instance;
		return instance;
	}	
	void levelAdvance(){passedLevel+=1;}
	void refreshTimesAdvance(){refreshTimes+=1;}
	void setRewardRefreshBase(const int base){rewardRefreshBase=base;}
	void setRewardRefreshRate(const float rate){rewardRefreshRate=rate;}
	void resetRefreshTimes(){refreshTimes=0;}
	void reset(){passedLevel=0;rewardRefreshRate=1.f;rewardRefreshBase=10;refreshTimes=0;}
	const int getRefreshMoney() const{return refreshTimes*rewardRefreshBase*rewardRefreshRate;}
	const int getRefreshTimes() const{return refreshTimes;}
	const int getPassedLevel() const{return passedLevel;}
	const int getCoinsEarned() const;
	const Reward& getReward(const int i);
	const int getRewardSize() const {return rewards.size();}
};
#endif
以下是BulletEffect.h中的内容：
#ifndef BULLETEFFECT_H
#define BULLETEFFECT_H
#include "EventSystem.h"
class Entity;
class BulletEffect{
protected:
	Occasion triggerTime;
public:
	BulletEffect(const Occasion time=Occasion::OnHit):triggerTime(time){}
	virtual void tryTrigger(Entity& shooter,const Occasion& timing)=0;
};
class GiveDamage:public BulletEffect{
private:
	int damage;
public:
	GiveDamage(const int dmg):damage(dmg){triggerTime=Occasion::OnHit;}
	void tryTrigger(Entity& shooter,const Occasion& timing)override;
};
#endif
以下是EffectManager.h中的内容：
#ifndef EFFECTMANAGER_H
#define EFFECTMANAGER_H
#include "InstantEffect.h"
#include "RelicEffect.h"
#include "nlohmann/json.hpp"
#include "InstantEffectFactory.h"
#include "RelicEffectFactory.h"
#include <memory>
#include <string>
#include <unordered_map>

class EffectManager{
private:
	EffectManager()=default;
	~EffectManager()=default;
public:
	EffectManager(const EffectManager&)=delete;
	void operator=(const EffectManager&)=delete;
	static EffectManager& Get(){
		static EffectManager instance;
		return instance;
	}
	//分发加载任务
	void loadEffects(const nlohmann::json&)const;
	//从InstantEffectLoader获取一个即时效果
	std::shared_ptr<InstantEffect> getInstantEffect(const std::string&)const;
	//Relic效果同理
	std::shared_ptr<RelicEffect> getRelicEffect(const std::string&) const;
};
class InstantEffectLoader{
private:
	InstantEffectLoader()=default;
	~InstantEffectLoader()=default;
	std::unordered_map<std::string, std::unique_ptr<InstantEffectFactory>> factories;
public:
	InstantEffectLoader(const InstantEffectLoader&)=delete;
	void operator=(const InstantEffectLoader&)=delete;
	static InstantEffectLoader& Get(){
		static InstantEffectLoader instance;
		return instance;
	}
	//加载json中即时效果数组的每一个元素的工厂
	void loadInstantEffect(const nlohmann::json& effects);
	//通过已加载的效果工厂创建效果
	std::shared_ptr<InstantEffect> getEffect(const std::string&);
};
//RelicEffect
class RelicEffectLoader{
private:
	RelicEffectLoader()=default;
	~RelicEffectLoader()=default;
	std::unordered_map<std::string, std::shared_ptr<RelicEffectFactory>> factories;
public:
	RelicEffectLoader(const RelicEffectLoader&)=delete;
	void operator=(const RelicEffectLoader&)=delete;
	static RelicEffectLoader& Get(){
		static RelicEffectLoader instance;
		return instance;
	}
	//加载json中遗物效果数组的每一个元素
	void loadRelicEffect(const nlohmann::json& json);
	//通过已加载的效果工厂创建效果
	std::shared_ptr<RelicEffect> getEffect(const std::string&);
};
#endif
以下是InstantEffectFactory.h中的内容：
#ifndef INSTANTEFFECTFACTORY_H
#define INSTANTEFFECTFACTORY_H
#include "InstantEffect.h"
#include "nlohmann/json.hpp"
#include <memory>
class InstantEffectFactory{
public:
	//创建一个即时效果，需要的固定参数都由加载时内置
	//可变参数由set()相关方法设置（需要时特化）
	virtual std::shared_ptr<InstantEffect> create()=0;
	virtual void loadFromJson(const nlohmann::json&)=0;
	InstantEffectFactory()=default;
	virtual ~InstantEffectFactory()=default;
};
template<typename T>
class ConcreteInstantEffectFactory:public InstantEffectFactory{
private:
	nlohmann::json params;
public:
	std::shared_ptr<InstantEffect> create() override{
		return std::make_shared<T>(params);
	}
	void loadFromJson(const nlohmann::json& p) override{
		params=p;
	}
};


#endif
以下是InstantEffect.h中的内容：
#ifndef INSTANTEFFECT_H
#define INSTANTEFFECT_H
#include <variant>
#include "nlohmann/json.hpp"
class Player;
class InstantEffect{
public:
	InstantEffect()=default;
	virtual void onApply(Player& player)const =0;
	virtual ~InstantEffect(){}
};

class SpeedBoost:public InstantEffect{
private:
	float rate;
public:
	SpeedBoost(const nlohmann::json& j):InstantEffect(){rate=j["rate"].get<float>();}
	void onApply(Player& player) const override final;
	virtual ~SpeedBoost() override;
};

class HealthBoost:public InstantEffect{
private:
	std::variant<int,float> value;
public:
	HealthBoost(const nlohmann::json& j):InstantEffect(){
		if(j["value"].is_number_float()){
			value=j["value"].get<float>();
		}else{
			value=j["value"].get<int>();
		}
	}
	void onApply(Player& player) const override final;
	virtual ~HealthBoost() override;
};

#endif
以下是RelicEffectFactory.h中的内容：
#ifndef RELICEFFECTFACTORY_H
#define RELICEFFECTFACTORY_H
#include "RelicEffect.h"
#include "nlohmann/json.hpp"
#include <memory>
class RelicEffectFactory{
public:
	virtual std::shared_ptr<RelicEffect> create()=0;
	virtual void loadFromJson(const nlohmann::json&)=0;
};
template<typename T>
class ConcreteRelicFactory:public RelicEffectFactory{
private:
	nlohmann::json params;
public:
	std::shared_ptr<RelicEffect> create() override{
		return std::make_unique<T>(params);
	}
	void loadFromJson(const nlohmann::json& relic) override{
		params=relic;
	}
};
#endif
以下是RelicEffect.h中的内容：
#ifndef RELICEFFECT_H
#define RELICEFFECT_H
#include <string>
class Entity;
class RelicEffect{
protected:
	bool isActive=false;
	std::string description;
public:
	RelicEffect()=default;
	virtual ~RelicEffect()=default;
	virtual void onTrigger(Entity& relatedEntity)=0;
	virtual std::string getDescription() const{return description;}
};

#endif
以下是Entity.h中的内容：
#ifndef ENTITY_H
#define ENTITY_H
extern "C"{
	#include "raylib.h"
}
#include <utility>
#include <vector>
#include <algorithm>
#include <memory>
#include <string>
#include "Bullet.h"
namespace GameInit{
	const int Start_Money=33;
}
class Entity{
protected:
	Vector2 position;
	Rectangle boxCollider;
	Texture2D texture;
	float attackInterval,attackTimer;//unit:second
	int maxHP,currentHP,energy,maxEnergy,energyRise;
	Entity* opponent;
	Blast blast;
	std::vector<Bullet> bulletPattern;
	std::size_t bulletIndex;
	std::vector<std::unique_ptr<Bullet>> bulletPool;
public:
	explicit Entity(const std::string texPath,const Vector2& pos,const int hp=100
	,const float interval=1,const int MAXenergy=100,const int rise=10
	,const std::vector<Bullet>& pattern={});

	~Entity()=default;
	virtual void Update(const float deltaTime)=0;
	virtual void Draw() const =0;
	virtual void drawHPandEnergy() const=0;
	void fire(Vector2 pos={0,0});
	void fireBlast();
	void takeDamage(const int damage){currentHP=std::max(0,currentHP-damage);}
	bool isAlive() const {return currentHP>0;}
	bool canCastSkill() const{return energy>=maxEnergy;}
	void addEnergy(const int value){
		energy=std::clamp(energy+value,0,maxEnergy);
	}
	void resetEnergy(){energy=0;}
	void reset();
	void addBullet(Bullet aBullet){bulletPattern.push_back(std::move(aBullet));}
	void removeBullet(const int index){bulletPattern.erase(bulletPattern.begin()+index);}
	void setBlast(Blast aBlast){blast=std::move(aBlast);}
	void setOpponent(Entity& opp){opponent=&opp;}
	float& getAttackTimer(){return attackTimer;}
	float& getAttackInterVale(){return attackInterval;}
	int& getEnergyRise(){return energyRise;}
	Entity& getOpponent(){return *opponent;}
	const int getEnergy() const{return energy;}
	const int getHP() const{return currentHP;}
	const int getMaxEnergy() const{return maxEnergy;}
	const Rectangle& getCollider() const{return boxCollider;}

};

class Player:public Entity{
private:
	int money=GameInit::Start_Money;
public:
	Player(const std::string texPath,const Vector2& pos,const int hp=100
	,const float interval=1,const int MAXenergy=100,const int rise=10)
	:Entity(texPath,pos,hp,interval,MAXenergy,rise){}
	void Update(const float deltaTime) override;
	void Draw() const override;
	void drawHPandEnergy() const override;
	void setAttackInterval(const float rate){attackInterval*=rate;}
	void MaxHealthBoost(const int val){maxHP+=val;}
	void MaxHealthBoost(const float rate){maxHP*=rate;}
	void addMoney(const int value){money+=value;}
	const bool deductMoney(const int value){
		if(money-value<0){return false;}
		else{money-=value;return true;}
	}
	const int getMoney() const{return money;}
};

class Enemy:public Entity{
public:
	Enemy(const std::string texPath,const Vector2& pos,const int hp=100
	,const float interval=1,const int MAXenergy=100,const int rise=10)
	:Entity(texPath,pos,hp,interval,MAXenergy,rise){}
	void Update(const float deltaTime) override;
	void Draw() const override;
	void drawHPandEnergy() const override;
};
#endif
以下是EventSystem.h中的内容：
#ifndef EVENTSYSTEM_H
#define EVENTSYSTEM_H
#include "Effect/RelicEffect.h"
#include <memory>
#include <unordered_map>
#include <vector>
class Entity;
enum class Occasion{
	OnShoot,
	OnHit,
	Instant,
	Always,
	OnBattleStart,
	OnPlayerHit,
	OnHPThreshold,
	Undecided
};
class EventSystem{
private:
	EventSystem()=default;
	~EventSystem()=default;
	std::unordered_map<Occasion,std::vector<std::shared_ptr<RelicEffect>>> listeners;
public:
	//将某个遗物和事件绑定在一起
	void bindRelicAndEvent(std::shared_ptr<RelicEffect>,Occasion);
	//广播某事件
	void broadcastEvent(Occasion);

};
#endif
以下是GameStageFwd.h中的内容：
#ifndef GAMESTAGEFWD_H
#define GAMESTAGEFWD_H

enum class GameStage{MainMenu,Battle,Victory,Defeat,Pause,EXIT};
enum class EventSignal{IDLE,EXIT,RESTART};
#endif
以下是GameStage.h中的内容：
#ifndef GAMESTAGE_H
#define GAMESTAGE_H
#include "Entity.h"
#include "GameStageFwd.h"


class StageController{
private:
	GameStage currentStage;
	EventSignal signal;
	Player* player;
	Enemy* enemy;
	StageController();
	~StageController()=default;
	void battleUpdate();
	void mainMenuUpdate();
	void pauseUpdate();
	void victoryUpdate();
	void defeatUpdate();	
public:
	StageController(const StageController&)=delete;
	void operator=(const StageController&)=delete;
	static StageController& Get(){
		static StageController instance;
		return instance;
	}
	void resetGame();
	void bindEntities(Player& p,Enemy& e){player=&p;enemy=&e;}
	void update();
	const GameStage getCurrentStage() const {return currentStage;}
	void transitionTo(const GameStage stage){currentStage=stage;}
};

#endif
以下是ResourceManager.h中的内容：
#ifndef RESOURCEMANAGER_H
#define RESOURCEMANAGER_H
#include <unordered_map>
#include <string>
extern "C"{
	#include "raylib.h"
}
namespace UI {
	const std::string FONT_PATH="";
}
class ResourceManager{
private:
	std::unordered_map<std::string, Texture2D> textures;
	Font font;
	bool isFontAssigned=false;
	ResourceManager()=default;
	~ResourceManager()=default;
public:
	ResourceManager(const ResourceManager&)=delete;
	void operator=(const ResourceManager&)=delete;
	static ResourceManager& Get(){
		//利用C++11局部静态变量特性
		static ResourceManager instance;
		return instance;
	}
	std::string resizeTexture(const std::string path,const int width,const int height);
	const Texture2D& loadTexture(const std::string path);
	std::unordered_map<std::string, Texture2D>& getTextures(){return textures;}
	const Font& loadFont();
	void unloadTexture(const std::string path);
	void cleanUp();
};

#endif
以下是RewardSystem.h中的内容：
#ifndef REWARDSYSTEM_H
#define REWARDSYSTEM_H

#include <memory>
#include <string>
#include "Effect/InstantEffect.h"
extern "C"{
	#include "raylib.h"
}
class Entity;
struct Reward{
	std::string name;
	std::string description;
	std::shared_ptr<InstantEffect> effect;
	Texture2D icon;
	void applyToEntity(Entity& entity);
	void getEffect(const std::string& id);
};

#endif
以下是UIComponent.h中的内容：
#ifndef UICOMPONENT_H
#define UICOMPONENT_H
#include <string>
extern "C"{
	#include "raylib.h"
}
namespace UI{
	const int BASIC_BUTTON_WIDTH = 200;
	const int BASIC_BUTTON_HEIGHT = 50;
	const float WIDTH_RADIO=0.9f;
	const float HEIGHT_RADIO=0.5f;
	const int MIN_FONT_SIZE=1;	
	const int FONTSIZE=40;
	const int EXPLAIN_FONTSIZE=15;
	const float countTextPosX(const std::string& str,const int origin,const int fontSize,const int offset=0);
	
}

class Button{
protected:
	bool available=true;
	Rectangle rect;
	std::string text;
	Color color;
	int fontSize;
	Vector2 textPos;
	void resetPosAndSize();
public:
	virtual void Draw() const;
	const Rectangle& getRect() const{return rect;}
	void setAvailibility(const bool a){available=a;}
	void setText(const std::string& str){text=str;resetPosAndSize();}
	std::string getText()const{return text;}
	Button()=default;
	Button(Rectangle r,std::string t,Color c);
};
class ButtonWithNumber:public Button{
private:
	std::string addition;
public:
	ButtonWithNumber()=default;
	ButtonWithNumber(Rectangle r,std::string t,Color c,std::string a="")
	:Button(r,t,c),addition(a){}
	void setAddition(const std::string& str){addition=str;}
	void Draw() const override;
};
class ButtonWithExplain:public Button{
private:
	std::string explain;
	void DrawExplain() const;
public:
	ButtonWithExplain()=default;
	ButtonWithExplain(Rectangle r,std::string t,Color c,std::string e):Button(r,t,c),explain(e){}
	void setExplain(const std::string& str){explain=str;}
	void Draw() const override;
};

#endif
以下是UI.h中的内容：
#ifndef UI_H
#define UI_H
#include "Entity.h"
#include "RewardSystem.h"
#include <vector>
#include "UIComponent.h"
extern "C"{
}
namespace UI {
	const int MAX_ENGLISH_EXPLAIN_LINE=24;
}
class DefeatUI{
private:
	Button restartButton,exitButton;
	DefeatUI();
	~DefeatUI()=default;
public:
	DefeatUI(const DefeatUI&)=delete;
	void operator=(const DefeatUI&)=delete;
	static DefeatUI& Get(){
		static DefeatUI instance;
		return instance;
	}
	const Button& getRestartBtn() const{return restartButton;}
	const Button& getExitBtn() const{return exitButton;}
	void Draw() const;
};
class VictoryUI{
private:
	VictoryUI();
	~VictoryUI()=default;
	ButtonWithExplain rewardBtn[3];
	ButtonWithNumber refreshBtn;
	std::vector<Reward> currentRewards;
public:
	VictoryUI(const VictoryUI&)=delete;
	void operator=(const VictoryUI&)=delete;
	static VictoryUI& Get(){
		static VictoryUI instance;
		return instance;
	}
	void Draw() const;
	void tryGenerateRewards(Player& player);
	void chooseReward(const int i,Player& player);
	const Button& getRewardBtn(int i) const{return rewardBtn[i];}
	const ButtonWithNumber& getRefreshBtn() const{return refreshBtn;}
};

#endif
以下是CMakeLists.txt中的内容：
#./src的CMakeLists.txt
cmake_minimum_required(VERSION 3.5.0)
project(SuperKLF_alpha)
file(GLOB PROJECT_SOURCES CONFIGURE_DEPENDS ${SRC}/*.cpp)
add_executable(${PROJECT_NAME})
target_sources(${PROJECT_NAME} PRIVATE ${PROJECT_SOURCES})
target_include_directories(${PROJECT_NAME} PRIVATE ${HEADPATH})
#依赖库，每次添加库组件都要在这里加上
target_link_libraries(${PROJECT_NAME} PRIVATE 
	raylib
	Entity
	Collision
	ResourceManager
	GameStage
	SpecialEffect
	EffectManager
	UIComponent
	UI
	Data
	RewardSystem)
target_link_directories(${PROJECT_NAME} PRIVATE ${LIBPATH})
以下是CMakeLists.txt中的内容：
#Collision中的CMakeLists.txt
cmake_minimum_required(VERSION 3.5.0)
#每个依赖库的名字
project(Collision)
file(GLOB CURRENT_FILE ${PROJECT_SOURCE_DIR}/*.cpp)
add_library(${PROJECT_NAME} STATIC ${CURRENT_FILE})
target_include_directories(${PROJECT_NAME} PUBLIC ${HEADPATH})

target_link_directories(${PROJECT_NAME} PRIVATE ${LIBPATH})
以下是Collision.cpp中的内容：
#include "Collision.h"
#include <algorithm>
extern "C"{
	#include <raylib.h>
}
using std::clamp;

bool Collision::checkBulletEntity(const Bullet &aBullet, const Entity &aEntity){
	Vector2 bulletCentre=aBullet.getColliderCentre();
	float bulletRadiu=aBullet.getColliderRadius();

	Rectangle entityBox=aEntity.getCollider();

	//计算矩形边界点与圆心最近的距离
	float closestX=clamp(bulletCentre.x,entityBox.x,entityBox.x+entityBox.width);
	float closestY=clamp(bulletCentre.y,entityBox.y,entityBox.y+entityBox.height);
	float distanceX=bulletCentre.x-closestX;
	float distanceY=bulletCentre.y-closestY;
	float distanceSquare=(distanceX*distanceX)+(distanceY*distanceY);
	return distanceSquare<=(bulletRadiu*bulletRadiu);
}
bool Collision::checkEntityEntity(const Entity &a, const Entity &b){
	return CheckCollisionRecs(a.getCollider(), b.getCollider());
}
bool Collision::checkIsTouchButton(const Button &aButton){
	return CheckCollisionPointRec(GetMousePosition(), aButton.getRect());
}
以下是Bullet.cpp中的内容：
#include <algorithm>
#include <memory>
#include <string>
#include <vector>
extern "C"{
	#include "raylib.h"
}
#include "Bullet.h"
#include "Entity.h"
#include "Collision.h"
#include "ResourceManager.h"

const bool isOutOfScreen(const Vector2& pos);

Bullet::Bullet(const std::string texPath,const Vector2& vel,const Vector2& pos,const int dmg,const bool act)
	:position(pos),velocity(vel),active(act),damage(dmg),texturePath(texPath){
		Texture2D origin=ResourceManager::Get().loadTexture(texPath);
		texturePath=ResourceManager::Get().resizeTexture(texPath, BULLET::BULLET_SIZE.x, BULLET::BULLET_SIZE.y);
		texture=ResourceManager::Get().loadTexture(texturePath);
		countColliderRadius();
		effects.push_back(std::make_shared<GiveDamage>(GiveDamage(damage)));
	}
void Bullet::countColliderRadius(const Vector2 size){
	colliderRadius=drawScale*(std::min(size.x,size.y)/2);
}

Bullet::Bullet(const Bullet& proto,const Vector2& begin)
	:position(begin),velocity(proto.velocity),active(true)
	,colliderRadius(proto.colliderRadius),damage(proto.damage)
	,texture(proto.texture),drawScale(proto.drawScale){
		effects=proto.effects;
	}

std::unique_ptr<Bullet> Bullet::shoot(const Vector2& begin){
	if(active==false){
		//子弹原型时（只有原型会调用这个函数）
		return std::make_unique<Bullet>(*this,begin);
	}else{
		return nullptr;
	}
}
void Bullet::Update(const float deltaTime,Entity& shooter){
	if(active&&!shouldRemove){
		if(isOnShoot){
			tryTriggerEffects(shooter, Occasion::OnShoot);
			isOnShoot=false;
		}
		position.x+=velocity.x*deltaTime*BULLET::BASIC_SPEED;
		position.y+=velocity.y*deltaTime*BULLET::BASIC_SPEED;
		Draw();
		checkHit(shooter);	
	}
}
void Bullet::checkHit(Entity& shooter) {
	if(Collision::checkBulletEntity(*this, shooter.getOpponent())){
		tryTriggerEffects(shooter, Occasion::OnHit);
		shouldRemove=true;
	}else{
		if(isOutOfScreen(this->getColliderCentre())){
			shouldRemove=true;
		}
	}
}
void Bullet::tryTriggerEffects(Entity& shooter,const Occasion& timing){
	for(auto& effect :effects){
		effect->tryTrigger(shooter, timing);
	}
}
void Bullet::Draw() const { 
	if(IsTextureValid(texture)){
		DrawTextureEx(texture,position,0,drawScale,WHITE); 
		DrawCircleLinesV(getColliderCentre(),colliderRadius,BLUE);
	}
}
const bool isOutOfScreen(const Vector2& pos){
	if(pos.x>GetScreenWidth()||pos.x<0){
		return true;
	}
	if(pos.y>GetScreenWidth()||pos.y<0){
		return true;
	}
	return false;
}
以下是CMakeLists.txt中的内容：
#Entity中的CMakeLists.txt
cmake_minimum_required(VERSION 3.5.0)
#每个依赖库的名字
project(Entity)
file(GLOB CURRENT_FILE ${PROJECT_SOURCE_DIR}/*.cpp)
add_library(${PROJECT_NAME} STATIC ${CURRENT_FILE})
target_include_directories(${PROJECT_NAME} PUBLIC ${HEADPATH})

target_link_directories(${PROJECT_NAME} PRIVATE ${LIBPATH})
以下是Entity.cpp中的内容：
#include "Entity.h"
#include "Bullet.h"
#include "ResourceManager.h"
#include <memory>

extern "C"{
	#include "raylib.h"
}

void updateBulletPool(std::vector<std::unique_ptr<Bullet>>& pool,const float deltaTime,Entity& shooter);
void tryFire(Entity& aEntity,const float deltaTime);
void updateCollision(std::vector<std::unique_ptr<Bullet>>& pool,const float deltaTime,Entity& shooter);

Entity::Entity(const std::string texPath,const Vector2& pos,const int hp,const float interval,const int MAXenergy,const int rise,const std::vector<Bullet>& pattern)
		:position(pos),maxHP(hp),attackInterval(interval),
		 attackTimer(0),energy(0),maxEnergy(MAXenergy),energyRise(rise),
		 bulletIndex(0),bulletPattern(pattern),currentHP(hp),
		 bulletPool{}{
			texture=ResourceManager::Get().loadTexture(texPath);
			if(!IsTextureValid(texture)){
				//当加载不成功时，使用临时图标
				TraceLog(LOG_WARNING, "Using fallback texture for: %s",texPath.c_str());
				texture=ResourceManager::Get().loadTexture(ASSETS_IMAGE_PATH "/fallback.png");
			}
			boxCollider={position.x,position.y,(float)texture.width,(float)texture.height};
		 }
void Entity::reset(){
	currentHP=maxHP;
	energy=0;
	bulletIndex=0;
	bulletPool.clear();
}
void Entity::fire(Vector2 pos){
	if(bulletPattern.empty()){
		return;
	}
	if(pos.x==0&&pos.y==0){
		pos.x=position.x;
		pos.y=position.y;
	}
	bulletPool.push_back(bulletPattern[bulletIndex].shoot(pos));
	bulletIndex=(bulletIndex+1) % bulletPattern.size();
	addEnergy(energyRise);
}
void Entity::fireBlast(){
	bulletPool.push_back(blast.shoot(position));
	resetEnergy();
}

void Player::Update(const float deltaTime){
	tryFire(*this, deltaTime);
	updateBulletPool(bulletPool, deltaTime,*this);
}
void Player::Draw() const {
	DrawTextureV(texture,position,WHITE);
	drawHPandEnergy();
	DrawRectangleLinesEx(boxCollider,5,RED);
}
void Player::drawHPandEnergy() const{
	DrawRectangleLines(0, GetScreenHeight()-40, int(GetScreenWidth()/2), 40, BLACK);
	DrawRectangle(0, GetScreenHeight()-40, int((float(currentHP)/maxHP)*(float(GetScreenWidth())/2)), 40, RED);
	DrawRectangleLines(int(GetScreenWidth()/2), GetScreenHeight()-40, int(GetScreenWidth()/2), 40, BLACK);
	DrawRectangle(int(GetScreenWidth()/2), GetScreenHeight()-40, int((float(energy)/maxEnergy)*(float(GetScreenWidth())/2)), 40, ORANGE);	
}
void Enemy::Update(const float deltaTime){
	tryFire(*this, deltaTime);
	updateBulletPool(bulletPool, deltaTime,*this);
}
void tryFire(Entity& shooter,const float deltaTime){
	float& attackTimer=shooter.getAttackTimer();
	float& attackInterval=shooter.getAttackInterVale();
	attackTimer+=deltaTime;
	if(shooter.getEnergy()==shooter.getMaxEnergy()){
		shooter.fireBlast();
	}	
	if(attackTimer>=attackInterval){
		shooter.fire();
		attackTimer=0;
		shooter.addEnergy(shooter.getEnergyRise());
	}

}

void updateBulletPool(std::vector<std::unique_ptr<Bullet>>& pool,const float deltaTime,Entity& shooter){
	for(auto it=pool.begin();it!=pool.end();){
		(*it)->Update(deltaTime,shooter);
		if((*it)->shouldBeRemoved()){
			it=pool.erase(it);
		}else{
			++it;
		}
	}	
}
void Enemy::Draw() const {
	DrawTextureV(texture,position,WHITE);
	drawHPandEnergy();
	DrawRectangleLinesEx(boxCollider,5,RED);
}
void Enemy::drawHPandEnergy() const{
	DrawRectangleLines(0, 0, int(GetScreenWidth()/2), 40, BLACK);
	DrawRectangle(0, 0, int((float(currentHP)/maxHP)*(float(GetScreenWidth())/2)), 40, RED);
	DrawRectangleLines(int(GetScreenWidth()/2), 0, int(GetScreenWidth()/2), 40, BLACK);
	DrawRectangle(int(GetScreenWidth()/2), 0, int((float(energy)/maxEnergy)*(float(GetScreenWidth())/2)), 40, ORANGE);	
}


以下是main.cpp中的内容：
#ifndef ASSETS_IMAGE_PATH
#define ASSETS_IMAGE_PATH
#include "DataManager.h"
#endif

extern "C" {
	#include "raylib.h"
}
#include "Effect/EffectManager.h"
#include "EffectManager.h"
#include "DataManager.h"
#include "GameStageFwd.h"
#include "ResourceManager.h"
#include "GameStage.h"

const int WindowWidth=1280;
const int WindowHeight=720;

const Vector2 playerPos={640,500};
const Vector2 enemyPos={640,100};
const Vector2 playerVel={0,-1};
const Vector2 enemyVel={0,1};
using playerPtr=std::unique_ptr<Player>;
using enemyPtr=std::unique_ptr<Enemy>;

void RegisterEffects();
void entityInit(std::unique_ptr<Player>&,std::unique_ptr<Enemy>&);
bool shouldEnd();
int main(void){
	RegisterEffects();
	InitWindow(WindowWidth,WindowHeight,"SuperKLF");
	StageController& state=StageController::Get();
	ResourceManager& resMgr=ResourceManager::Get();
	std::unique_ptr<Player> player;
	std::unique_ptr<Enemy> enemy;
	entityInit(player, enemy);
	SetTargetFPS(180);
	state.transitionTo(GameStage::Battle);
	while(!shouldEnd()){
		BeginDrawing();
		ClearBackground(WHITE);
		DrawFPS(0, 0);
		state.update();
		EndDrawing();
	}
	resMgr.cleanUp();
	CloseWindow();
}
void RegisterEffects(){
	EffectManager::Get().loadEffects(DATA::EFFECT_PATH);
}
bool shouldEnd(){
	if(WindowShouldClose()){return true;}
	if(StageController::Get().getCurrentStage()==GameStage::EXIT){
		return true;
	}
	return false;
}

void entityInit(std::unique_ptr<Player>& player,std::unique_ptr<Enemy>& enemy){
	player.reset(new Player( ASSETS_IMAGE_PATH"player.png",playerPos,10,0.1,100,10));
	enemy.reset(new Enemy { ASSETS_IMAGE_PATH"enemy.png",enemyPos});
	player->setOpponent(*enemy);
	player->addBullet(Bullet( ASSETS_IMAGE_PATH"pen.png",playerVel));
	player->setBlast(Blast( ASSETS_IMAGE_PATH"warning.png",playerVel));
	enemy->setOpponent(*player);
	enemy->addBullet({ ASSETS_IMAGE_PATH"pen.png"});
	StageController::Get().bindEntities(*player, *enemy);	
}
以下是CMakeLists.txt中的内容：
#这是./src/Managers中的CMakeLists.txt
cmake_minimum_required(VERSION 3.5.0)
project(Managers)
add_subdirectory(${SRC}/Managers/ResourceManager)
add_subdirectory(${SRC}/Managers/GameStage)
add_subdirectory(${SRC}/Managers/Data)
add_subdirectory(${SRC}/Managers/Effect)
以下是CMakeLists.txt中的内容：
#Data中的CMakeLists.txt
cmake_minimum_required(VERSION 3.5.0)
#每个依赖库的名字
project(Data)
file(GLOB CURRENT_FILE ${PROJECT_SOURCE_DIR}/*.cpp)
add_library(${PROJECT_NAME} STATIC ${CURRENT_FILE})
target_include_directories(${PROJECT_NAME} PUBLIC ${HEADPATH})

target_link_directories(${PROJECT_NAME} PRIVATE ${LIBPATH})
以下是DataManager.cpp中的内容：
#include "DataManager.h"
#include "ResourceManager.h"
#include "nlohmann/json.hpp"
#include <fstream>
#include <string>
extern "C"{
	#include "raylib.h"
}

using json= nlohmann::json;

std::string autoSplit(const std::string&);
const int DataManager::getCoinsEarned() const{
	return DATA::BASIC_COINS_EARNED*DATA::BASIC_COINS_RATE*passedLevel;
}
DataManager::DataManager(){
	//用nlohmann json从data.json中读取存档信息等
	//从rewards.json读取可用奖励
	if(FileExists(DATA::REWARD_CONFIG_PATH.c_str())){
		std::ifstream file{DATA::REWARD_CONFIG_PATH};
		json data=json::parse(file);
		rewards.reserve(data.size());
		for(auto& item :data){
			Reward reward;
			reward.name=item["name"].get<std::string>();
			reward.description=autoSplit(item["description"].get<std::string>());
			reward.icon=ResourceManager::Get().loadTexture(item["icon_path"].get<std::string>());
			reward.getEffect(item["effectID"].get<std::string>());
			rewards.push_back(std::move(reward));
		}
	}
}
std::string autoSplit(const std::string& str){
	std::string newStr;
	for(int i=0;i<str.length();i++){
		newStr+=str[i];
		if(i%26==0&&i!=0){
			newStr+='\n';
		}
	}
	newStr+='\0';
	return newStr;
}
const Reward& DataManager::getReward(const int i){
	return rewards.at(i);
}
以下是CMakeLists.txt中的内容：
#ResourceManager中的CMakeLists.txt
cmake_minimum_required(VERSION 3.5.0)
#每个依赖库的名字
project(EffectManager)
file(GLOB CURRENT_FILE ${PROJECT_SOURCE_DIR}/*.cpp)
add_library(${PROJECT_NAME} STATIC ${CURRENT_FILE})
target_include_directories(${PROJECT_NAME} PUBLIC ${HEADPATH})

target_link_directories(${PROJECT_NAME} PRIVATE ${LIBPATH})
以下是EffectManager.cpp中的内容：
#include "Effect/EffectManager.h"
#include "Effect/InstantEffect.h"
#include "Effect/InstantEffectFactory.h"
#include "Effect/RelicEffect.h"
#include "Effect/RelicEffectFactory.h"
#include <memory>
using json = nlohmann::json;

void EffectManager::loadEffects(const json& json) const {
    InstantEffectLoader::Get().loadInstantEffect(json["InstantEffects"]);
    RelicEffectLoader::Get().loadRelicEffect(json["RelicEffects"]);
}

std::shared_ptr<InstantEffect> EffectManager::getInstantEffect(const std::string& id) const {
    return InstantEffectLoader::Get().getEffect(id);
}

std::shared_ptr<RelicEffect> EffectManager::getRelicEffect(const std::string& id) const {
    return RelicEffectLoader::Get().getEffect(id);
}
void InstantEffectLoader::loadInstantEffect(const json& effects) {
    std::string id, type;
    for (const auto& effect : effects) {
        id = effect["id"].get<std::string>();
        type = effect["type"].get<std::string>();
        std::unique_ptr<InstantEffectFactory> factory;
        if (type == "SpeedBoost") {
            factory = std::make_unique<ConcreteInstantEffectFactory<SpeedBoost>>();
        } else {
            // 其他类型处理
        }
        factory->loadFromJson(effect);
        factories[id] = std::move(factory);
    }
}

void RelicEffectLoader::loadRelicEffect(const json& relics) {
    std::string id, type;
    for (const auto& relic : relics) {
        id = relic["id"].get<std::string>();
        type = relic["type"].get<std::string>();
        std::unique_ptr<RelicEffectFactory> factory;
        if (type == "DoubleShootRelic") {
            // 处理 DoubleShootRelic 类型
        } else {
            // 其他类型处理
        }
        factory->loadFromJson(relic);
        factories[id] = std::move(factory);
    }
}

std::shared_ptr<InstantEffect> InstantEffectLoader::getEffect(const std::string& id) {
    return factories[id]->create();
}

std::shared_ptr<RelicEffect> RelicEffectLoader::getEffect(const std::string& id) {
    return factories[id]->create();
}
以下是CMakeLists.txt中的内容：
#StageController中的CMakeLists.txt
cmake_minimum_required(VERSION 3.5.0)
#每个依赖库的名字
project(GameStage)
file(GLOB CURRENT_FILE ${PROJECT_SOURCE_DIR}/*.cpp)
add_library(${PROJECT_NAME} STATIC ${CURRENT_FILE})
target_include_directories(${PROJECT_NAME} PUBLIC ${HEADPATH})

target_link_directories(${PROJECT_NAME} PRIVATE ${LIBPATH})
以下是GameStage.cpp中的内容：
#include "DataManager.h"
#include "Entity.h"
extern "C"{
	#include "raylib.h"
}
#include "GameStageFwd.h"
#include "GameStage.h"
#include "UI.h"
#include "Collision.h"

using Collision::checkIsTouchButton;


void responseToSignalFromDefeat(const EventSignal signal);
void drawDefeatScreen(const DefeatUI& ui);
const GameStage checkBattleStage(const Player* player,const Enemy* enemy);

StageController::StageController(){
	currentStage=GameStage::MainMenu;
	signal=EventSignal::IDLE;
	player=nullptr;
	enemy=nullptr;
}
void StageController::resetGame(){
	if(player==nullptr||enemy==nullptr){return;}
	player->reset();
	enemy->reset();
	DataManager::Get().reset();
}
void StageController::update(){
	switch(currentStage){
		case(GameStage::MainMenu):
		mainMenuUpdate();
		break;
		case(GameStage::Battle):
		battleUpdate();
		break;
		case(GameStage::Victory):
		victoryUpdate();
		break;
		case(GameStage::Defeat):
		defeatUpdate();
		break;
		case(GameStage::Pause):
		pauseUpdate();
		break;
		case(GameStage::EXIT):
		break;
	}	
}
void StageController::battleUpdate(){
	float deltaTime=GetFrameTime();
	player->Update(deltaTime);
	enemy->Update(deltaTime);
	player->Draw();
	enemy->Draw();
	currentStage=checkBattleStage(player, enemy);
}
const GameStage checkBattleStage(const Player* player,const Enemy* enemy){
	if(!player->isAlive()){return GameStage::Defeat;}
	if(!enemy->isAlive()){return GameStage::Victory;}
	return GameStage::Battle;
}
void StageController::defeatUpdate(){
	DefeatUI& ui=DefeatUI::Get();
	ui.Draw();
	if(IsKeyPressed(KEY_SPACE)){
		responseToSignalFromDefeat(EventSignal::RESTART);
		return;
	}
	if(checkIsTouchButton(ui.getRestartBtn())){
		if(IsMouseButtonPressed(MOUSE_BUTTON_LEFT)){
			responseToSignalFromDefeat(EventSignal::RESTART);
		}
	}
	if(checkIsTouchButton(ui.getExitBtn())){
		if(IsMouseButtonPressed(MOUSE_LEFT_BUTTON)){
			responseToSignalFromDefeat(EventSignal::EXIT);
		}
	}
}
void responseToSignalFromDefeat(const EventSignal signal){
	StageController& ctrl=StageController::Get();
	switch(signal){
		case(EventSignal::RESTART):
		ctrl.resetGame();
		ctrl.transitionTo(GameStage::Battle);
		break;
		case(EventSignal::EXIT):
		ctrl.transitionTo(GameStage::MainMenu);
		break;
		case(EventSignal::IDLE):
		break;
	}
}
void StageController::victoryUpdate(){
	VictoryUI& ui=VictoryUI::Get();
	if(DataManager::Get().getRefreshTimes()==0){
		ui.tryGenerateRewards(*player);
	}
	ui.Draw();
	if(checkIsTouchButton(ui.getRefreshBtn())){
		if(IsMouseButtonPressed(MOUSE_LEFT_BUTTON)){
			ui.tryGenerateRewards(*player);
		}
	}
	for(int i=0;i<3;i++){
		if(checkIsTouchButton(ui.getRewardBtn(i))){
			if(IsMouseButtonPressed(MOUSE_BUTTON_LEFT)){
				ui.chooseReward(i,*player);
			}
		}
	}
}
void StageController::pauseUpdate(){

}
void StageController::mainMenuUpdate(){
	transitionTo(GameStage::EXIT);
}
以下是CMakeLists.txt中的内容：
#ResourceManager中的CMakeLists.txt
cmake_minimum_required(VERSION 3.5.0)
#每个依赖库的名字
project(ResourceManager)
file(GLOB CURRENT_FILE ${PROJECT_SOURCE_DIR}/*.cpp)
add_library(${PROJECT_NAME} STATIC ${CURRENT_FILE})
target_include_directories(${PROJECT_NAME} PUBLIC ${HEADPATH})

target_link_directories(${PROJECT_NAME} PRIVATE ${LIBPATH})
以下是ResourceManager.cpp中的内容：
#include <string>
extern "C"{
	#include "raylib.h"
}

#include "ResourceManager.h"

const Texture2D& ResourceManager::loadTexture(const std::string path){
	if(textures.find(path)!=textures.end()){
		return textures[path];
	}
	if(!FileExists(path.c_str())){
		TraceLog(LOG_ERROR,"[RES] Texture not find: %s",path.c_str());
		return textures[""];
	}
	Texture2D tex=LoadTexture(path.c_str());
	if(!IsTextureValid(tex)){
		TraceLog(LOG_ERROR, "[RES] Failed to load: %s",path.c_str());
		return textures[""];
	}
	textures[path]=tex;
	TraceLog(LOG_INFO, "[RES] Loaded: %s (%d x %d)",path.c_str(),tex.width,tex.height);
	return textures[path];
}


std::string ResourceManager::resizeTexture(const std::string path,const int width,const int height){
	if(textures.find(path)==textures.end()){return "";}
	static int ID=0;
	Image img=LoadImageFromTexture(textures[path]);
	ImageResize(&img,width,height);
	std::string processedPath=path+"_porcessed"+std::to_string(ID);
	textures[processedPath]=LoadTextureFromImage(img);
	UnloadImage(img);
	ID++;
	return processedPath;
}

void ResourceManager::unloadTexture(const std::string path){
	if(textures.find(path)!=textures.end()){
		UnloadTexture(textures[path]);
		textures.erase(path);
		TraceLog(LOG_INFO, "[RES] Unloaded: %s",path.c_str());
	}
}

const Font& ResourceManager::loadFont(){
	if(isFontAssigned){return font;}
	if(UI::FONT_PATH==""){
		font=GetFontDefault();
	}else{
		font=LoadFont(UI::FONT_PATH.c_str());
	}
	return font;
}
void ResourceManager::cleanUp(){
	for(auto& [path,tex]:textures){
		UnloadTexture(tex);
	}
	textures.clear();
	UnloadFont(font);
	TraceLog(LOG_INFO, "[RES] All resources released");
}

以下是CMakeLists.txt中的内容：
#RewardSystem中的CMakeLists.txt
cmake_minimum_required(VERSION 3.5.0)
#每个依赖库的名字
project(RewardSystem)
file(GLOB CURRENT_FILE ${PROJECT_SOURCE_DIR}/*.cpp)
add_library(${PROJECT_NAME} STATIC ${CURRENT_FILE})
target_include_directories(${PROJECT_NAME} PUBLIC ${HEADPATH})

target_link_directories(${PROJECT_NAME} PRIVATE ${LIBPATH})
以下是RewardSystem.cpp中的内容：
#include "RewardSystem.h"
#include "Effect/EffectManager.h"
#include "Entity.h"
void Reward::getEffect(const std::string& id){
	EffectManager::Get().getInstantEffect(id);
}
void Reward::applyToEntity(Entity& entity){

}
以下是BulletEffect.cpp中的内容：
#include "Effect/BulletEffect.h"
#include "Entity.h"
void GiveDamage::tryTrigger(Entity& shooter,const Occasion& timing){
	if(timing==Occasion::OnHit){
		shooter.getOpponent().takeDamage(damage);
	}
}
以下是CMakeLists.txt中的内容：
#SpecialEffect中的CMakeLists.txt
cmake_minimum_required(VERSION 3.5.0)
#每个依赖库的名字
project(SpecialEffect)
file(GLOB CURRENT_FILE ${PROJECT_SOURCE_DIR}/*.cpp)
add_library(${PROJECT_NAME} STATIC ${CURRENT_FILE})
target_include_directories(${PROJECT_NAME} PUBLIC ${HEADPATH})
target_include_directories(${PROJECT_NAME} PUBLIC ${HEADPATH}/Effect)
target_link_directories(${PROJECT_NAME} PRIVATE ${LIBPATH})
以下是InstantEffect.cpp中的内容：
#include "Effect/InstantEffect.h"
#include "Entity.h"

void SpeedBoost::onApply(Player& player) const{
	player.setAttackInterval(rate);
}

void HealthBoost::onApply(Player& player) const{
	const int* intPtr=std::get_if<int>(&value);
	if(intPtr!=nullptr){
		player.MaxHealthBoost(*intPtr);
	}else{
		player.MaxHealthBoost(*(std::get_if<float>(&value)));
	}
}
以下是CMakeLists.txt中的内容：
#UI中的CMakeLists.txt
cmake_minimum_required(VERSION 3.5.0)
#每个依赖库的名字
project(UI)
file(GLOB CURRENT_FILE ${PROJECT_SOURCE_DIR}/*.cpp)
add_library(${PROJECT_NAME} STATIC ${CURRENT_FILE})
target_include_directories(${PROJECT_NAME} PUBLIC ${HEADPATH})

target_link_directories(${PROJECT_NAME} PRIVATE ${LIBPATH})
add_subdirectory(${SRC}/UI/UIComponent)
以下是CMakeLists.txt中的内容：
#UI中的CMakeLists.txt
cmake_minimum_required(VERSION 3.5.0)
#每个依赖库的名字
project(UIComponent)
file(GLOB CURRENT_FILE ${PROJECT_SOURCE_DIR}/*.cpp)
add_library(${PROJECT_NAME} STATIC ${CURRENT_FILE})
target_include_directories(${PROJECT_NAME} PUBLIC ${HEADPATH})

target_link_directories(${PROJECT_NAME} PRIVATE ${LIBPATH})
以下是UIComponent.cpp中的内容：
#include "UIComponent.h"
#include "ResourceManager.h"
#include "Collision.h"
extern "C"{
    #include "raylib.h"
}
const bool isButtonPressed(const Button& btn);
const bool isButtonHovered(const Button& btn);

const float UI::countTextPosX(const std::string& str,const int origin,const int fontSize,const int offset){
	float posX=origin;
	const Font& font=ResourceManager::Get().loadFont();
	posX-=MeasureTextEx(font, str.c_str(), fontSize, 1).x/2-offset;
	return posX;
}	


Button::Button(Rectangle r, std::string t, Color c) {
    rect = r;
    text = t;
    color = c;
	resetPosAndSize();
}
void Button::resetPosAndSize(){
    const float maxTextWidth = rect.width * UI::WIDTH_RADIO;
    const float maxTextHeight = rect.height * UI::HEIGHT_RADIO;
	const Font& font=ResourceManager::Get().loadFont();
    int low = UI::MIN_FONT_SIZE;
    int high = int(maxTextHeight);
    int bestSize = UI::MIN_FONT_SIZE;
    while (low <= high) {
        int mid = (low + high) / 2;
        Vector2 textSize = MeasureTextEx(font, text.c_str(), mid, 1);
        if (textSize.x <= maxTextWidth) {
            bestSize = mid;
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }
    fontSize = bestSize;
	Vector2 textSize=MeasureTextEx(font, text.c_str(), fontSize, 1);
    textPos = {
		UI::countTextPosX(text, rect.x, fontSize,(rect.width/2)),
        rect.y + (rect.height -textSize.y)/2
    };	
}

void Button::Draw() const{
	Color drawColor =color;
	const Font& font=ResourceManager::Get().loadFont();
	if(available){
		if(isButtonPressed(*this)){
			drawColor=ColorBrightness(color, -0.3f);
		}else if(isButtonHovered(*this)){
			drawColor=ColorBrightness(color, -0.15f);
		}
	}else{
		drawColor=DARKGRAY;
	}
	DrawRectangleRec(rect, drawColor);
	BeginScissorMode(rect.x, rect.y, rect.width, rect.height);
	DrawTextEx(font, text.c_str(), textPos, fontSize, 1, WHITE);
	EndScissorMode();
}
void ButtonWithExplain::Draw() const{
	Button::Draw();
	if(isButtonHovered(*this)&&available){
        DrawExplain();
	}  
}
void ButtonWithExplain::DrawExplain() const{
    Rectangle explainBox={
        rect.x,rect.y+rect.height,rect.width,rect.height*2.5f
    };
    DrawRectangleRec(explainBox, ColorBrightness(color, 0.15f));
    Vector2 position={explainBox.x,explainBox.y};
    DrawTextEx(ResourceManager::Get().loadFont(), explain.c_str(), position, UI::EXPLAIN_FONTSIZE, 1, WHITE);
}

void ButtonWithNumber::Draw() const{
	Color drawColor =color;
	const Font& font=ResourceManager::Get().loadFont();
	if(available){
		if(isButtonPressed(*this)){
			drawColor=ColorBrightness(color, -0.3f);
		}else if(isButtonHovered(*this)){
			drawColor=ColorBrightness(color, -0.15f);
		}
	}else{
		drawColor=DARKGRAY;
	}
	DrawRectangleRec(rect, drawColor);
	BeginScissorMode(rect.x, rect.y, rect.width, rect.height);
	DrawTextEx(font, (text+addition).c_str(), textPos, fontSize, 1, WHITE);
	EndScissorMode();
}

const bool isButtonPressed(const Button& btn){
	return isButtonHovered(btn)&&IsMouseButtonPressed(MOUSE_LEFT_BUTTON);
}
const bool isButtonHovered(const Button& btn){
	return Collision::checkIsTouchButton(btn);
}
以下是UI.cpp中的内容：
#include "UI.h"
#include "DataManager.h"
#include "Entity.h"
#include "RewardSystem.h"
#include "UIComponent.h"
#include <string>
#include <random>
extern "C"{
	#include "raylib.h"
}

void DefeatUI::Draw() const{
	ClearBackground(WHITE);
	const int screenHeight=GetScreenHeight();
	const int screenWidth=GetScreenWidth();	
	DrawRectangle(0, 0, screenWidth, screenHeight, Fade(BLACK,0.5f));
	std::string title="Mamba Out!";
	std::string subTitle=R"(You have passed %d levels!)";
	DrawText(title.c_str(),UI::countTextPosX(title,screenWidth/2,2*UI::FONTSIZE),200,2*UI::FONTSIZE,RED);
	DrawText(TextFormat(subTitle.c_str(),DataManager::Get().getPassedLevel()), UI::countTextPosX(subTitle, screenWidth/2, UI::FONTSIZE), 350, UI::FONTSIZE, RED);
	restartButton.Draw();
	exitButton.Draw();
}

DefeatUI::DefeatUI(){
	const int screenHeight=GetScreenHeight();
	const int screenWidth=GetScreenWidth();
	restartButton={
	{screenWidth/2.0f-UI::BASIC_BUTTON_WIDTH/2.0f,
		screenHeight*0.6f,
		UI::BASIC_BUTTON_WIDTH,
		UI::BASIC_BUTTON_HEIGHT},
	"[Space]Restart",ORANGE};
	exitButton={{
		screenWidth/2.0f-UI::BASIC_BUTTON_WIDTH/2.0f,
		screenHeight*0.75f,
		UI::BASIC_BUTTON_WIDTH,
		UI::BASIC_BUTTON_HEIGHT},
		"Quit",ORANGE};
}
VictoryUI::VictoryUI(){
	const int screenHeight=GetScreenHeight();
	const int screenWidth=GetScreenWidth();
	refreshBtn={{screenWidth/2.0f-UI::BASIC_BUTTON_WIDTH/2.0f,
		screenHeight*0.8f,
		UI::BASIC_BUTTON_WIDTH,
		UI::BASIC_BUTTON_HEIGHT},
		"Refresh",ORANGE};
	for(int i=0;i<3;i++){
		rewardBtn[i]={
			{GetScreenWidth()/5.0f*(i+2)-UI::BASIC_BUTTON_WIDTH,
			GetScreenHeight()*0.5f,
			UI::BASIC_BUTTON_WIDTH,
			UI::BASIC_BUTTON_HEIGHT},
			"Reward",ORANGE,"Explain"};
	}			
}
void VictoryUI::tryGenerateRewards(Player& player){
	player.deductMoney(DataManager::Get().getRefreshMoney());
	std::random_device rd;
	std::mt19937 gen(rd());
	std::uniform_int_distribution<> dis(0,DataManager::Get().getRewardSize()-1);
	currentRewards.clear();
	for(int i=0;i<3;i++){
		currentRewards.push_back(DataManager::Get().getReward(dis(gen)));
		rewardBtn[i].setText(currentRewards[i].name);
		rewardBtn[i].setExplain(currentRewards[i].description);
	}
	DataManager::Get().refreshTimesAdvance();
	if(player.getMoney()<=DataManager::Get().getRefreshMoney()){
		refreshBtn.setAvailibility(false);
	}else{
		refreshBtn.setAvailibility(true);
	}
	refreshBtn.setAddition("(-"+std::to_string(DataManager::Get().getRefreshMoney())+")");
}
void VictoryUI::chooseReward(const int i,Player& player){
	DataManager::Get().resetRefreshTimes();
	Reward reward=currentRewards[i];
}

void VictoryUI::Draw() const{
	ClearBackground(WHITE);
	const int screenHeight=GetScreenHeight();
	const int screenWidth=GetScreenWidth();
	DrawRectangle(0, 0, screenWidth, screenHeight, Fade(BLACK,0.5f));
	std::string subTitle=R"(You passed %d levels!)";
	DrawText(TextFormat(subTitle.c_str(),DataManager::Get().getPassedLevel()), UI::countTextPosX(subTitle, screenWidth/2, 2*UI::FONTSIZE), 200, 2*UI::FONTSIZE, RED);
	for(int i=0;i<3;i++){
		rewardBtn[i].Draw();
	}
	refreshBtn.Draw();
}
